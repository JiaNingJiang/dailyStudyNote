## 一、初始化客户端

用Go初始化以太坊客户端是和区块链交互所需的基本步骤。首先，导入go-etherem的`ethclient`包并通过调用接收区块链服务提供者URL的`Dial`来初始化它。

若您没有现有以太坊客户端，您可以连接到infura网关。Infura管理着一批安全，可靠，可扩展的以太坊[geth和parity]节点，并且在接入以太坊网络时降低了新人的入门门槛。

```go
client, err := ethclient.Dial("https://cloudflare-eth.com")
```

若您运行了本地geth实例，您还可以将路径传递给IPC端点文件。

```go
client, err := ethclient.Dial("/home/user/.ethereum/geth.ipc")
```

对每个Go以太坊项目，使用ethclient是开始的必要事项

### 1. 使用Ganache

[Ganache](https://github.com/trufflesuite/ganache-cli)(正式名称为testrpc)是一个用Node.js编写的以太坊实现**(本地的模拟以太坊)**，**用于在本地开发去中心化应用程序时进行测试**。现在我们将带着您完成安装并连接到它。

首先通过[NPM](https://www.npmjs.com/package/ganache-cli)安装ganache。

```bash
npm install -g ganache-cli
```

然后在本地运行ganache cli客户端。

```bash
ganache-cli
```

现在连到`http://localhost:8584`上的ganache RPC主机。

```go
client, err := ethclient.Dial("http://localhost:8545")
if err != nil {
  log.Fatal(err)
}
```

在启动ganache时，您还可以使用相同的助记词(就是后面的一大串字符串)来生成相同序列的公开地址。

```bash
ganache-cli -m "much repair shock carbon improve miss forget sock include bullet interest solution"
```

### 2.完整代码

```go
package main

import (
    "fmt"
    "log"

    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://cloudflare-eth.com")  //直接连接以太坊
    //client, err := ethclient.Dial("http://localhost:8545")   //使用ganache-cli
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("we have a connection")
    _ = client // we'll use this in the upcoming sections
}
```

## 二、以太坊账户

### 1. 读取账户余额

读取一个账户的余额相当简单。**调用客户端的`BalanceAt`方法**，给它传递**账户地址**和**可选的区块号**。将**区块号设置为`nil`将返回最新的余额**(以wei为单位)。

```go
account := common.HexToAddress("0x71c7656ec7ab88b098defb751b7401b5f6d8976f")  //转化为Address类型
balance, err := client.BalanceAt(context.Background(), account, nil)    //获取账户余额(wei为单位)
if err != nil {
  log.Fatal(err)
}

fmt.Println(balance) // 25893180161173005034    以wei为单位
```

传区块号能让您**读取该区块时的账户余额**。**区块号必须是`big.Int`类型**。

```go
blockNumber := big.NewInt(5532993)
balance, err := client.BalanceAt(context.Background(), account, blockNumber)
if err != nil {
  log.Fatal(err)
}

fmt.Println(balance) // 25729324269165216042   以wei为单位
```

以太坊中的数字是使用尽可能小的单位来处理的，因为它们是定点精度，在ETH中它是*wei*。要**读取ETH值**，您**必须做计算`wei/10^18`**。因为我们正在处理大数，我们得导入原生的Go`math`和`math/big`包。这是您做的转换。

```go
fbalance := new(big.Float)
fbalance.SetString(balance.String())
ethValue := new(big.Float).Quo(fbalance, big.NewFloat(math.Pow10(18)))

fmt.Println(ethValue) // 25.729324269165216041   转化后得到ETH值
```

#### 1.1 待处理的余额

有时您想知道**待处理的账户余额**是多少，例如，在**提交或等待交易确认后**。客户端提供了类似`BalanceAt`的方法，名为`PendingBalanceAt`，它接收账户地址作为参数。

```go
pendingBalance, err := client.PendingBalanceAt(context.Background(), account)
fmt.Println(pendingBalance) // 25729324269165216042   以wei为单位
```

#### 1.2 完整代码

```go
package main

import (
    "context"
    "fmt"
    "log"
    "math"
    "math/big"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://cloudflare-eth.com")
    if err != nil {
        log.Fatal(err)
    }

    account := common.HexToAddress("0x71c7656ec7ab88b098defb751b7401b5f6d8976f")
    balance, err := client.BalanceAt(context.Background(), account, nil)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(balance) // 25893180161173005034

    blockNumber := big.NewInt(5532993)
    balanceAt, err := client.BalanceAt(context.Background(), account, blockNumber)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(balanceAt) // 25729324269165216042

    fbalance := new(big.Float)
    fbalance.SetString(balanceAt.String())
    ethValue := new(big.Float).Quo(fbalance, big.NewFloat(math.Pow10(18)))
    fmt.Println(ethValue) // 25.729324269165216041

    pendingBalance, err := client.PendingBalanceAt(context.Background(), account)
    fmt.Println(pendingBalance) // 25729324269165216042
}
```

### 2. 生成新钱包

#### 2.1 生成私钥

要**首先生成一个新的钱包**，我们需要导入go-ethereum/crypto包，该包提供用于**生成随机私钥的GenerateKey方法**。

```go
privateKey, err := crypto.GenerateKey()
if err != nil {
  log.Fatal(err)
}
```

然后我们可以通过导入golangcrypto/ecdsa包并使用FromECDSA方法**将其转换为字节**。

```go
privateKeyBytes := crypto.FromECDSA(privateKey)
```

我们现在可以使用go-ethereum/hexutil包将它转换为**十六进制字符串**，该包提供了一个形参为字节切片的Encode方法。 然后我们**在十六进制编码之后删除“0x”**。

```go
fmt.Println(hexutil.Encode(privateKeyBytes)[2:])
//fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19
```

这就是用于签署交易的私钥，将被视为密码，永远不应该被共享给别人，因为谁拥有它可以访问你的所有资产。

#### 2.2 通过私钥生成公钥

由于**公钥是从私钥派生的**，因此go-ethereum的**加密私钥具有一个返回公钥的`Public`方法**。

```go
publicKey := privateKey.Public()
```

将其转换为十六进制的过程与我们使用转化私钥的过程类似。 我们**剥离了0x和前2个字符04**，它始终是EC前缀，不是必需的。

```go
publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
if !ok {
  log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
}

publicKeyBytes := crypto.FromECDSAPub(publicKeyECDSA)   //转化为byte字节流
fmt.Println(hexutil.Encode(publicKeyBytes)[4:])   //将byte字节流转化为十六进制字符串(并删除前缀字符)
//9a7df67f79246283fdc93af76d4f8cdd62c4886e8cd870944e817dd0b97934fdd7719d0810951e03418205868a5c1b40b192451367f28e0088dd75e15de40c05
```

#### 2.3 通过公钥获取账户公共地址

现在我们拥有公钥，就可以轻松生成你经常看到的公共地址。 为了做到这一点，go-ethereum加密包有一个`PubkeyToAddress`方法，它**接受一个ECDSA公钥，并返回公共地址**。

```go
address := crypto.PubkeyToAddress(*publicKeyECDSA).Hex()
fmt.Println(address) // 0x96216849c49358B10257cb55b28eA603c874b05E
```

公共地址其实就是计算公钥的Keccak-256哈希，然后我们取最后40个字符（20个字节）并用“0x”作为前缀。 以下是使用 `golang.org/x/crypto/sha3` 的 Keccak256函数手动实现 crypto.PubkeyToAddress()的过程。

```go
hash := sha3.NewLegacyKeccak256()
hash.Write(publicKeyBytes[1:])
fmt.Println(hexutil.Encode(hash.Sum(nil)[12:])) // 0x96216849c49358b10257cb55b28ea603c874b05e
```

#### 2.4 完整代码

```go
package main

import (
    "crypto/ecdsa"
    "fmt"
    "log"

    "github.com/ethereum/go-ethereum/common/hexutil"
    "github.com/ethereum/go-ethereum/crypto"
    "golang.org/x/crypto/sha3"
)

func main() {
    //生成私钥
    privateKey, err := crypto.GenerateKey()
    if err != nil {
        log.Fatal(err)
    }
	//打印私钥
    privateKeyBytes := crypto.FromECDSA(privateKey)
    fmt.Println(hexutil.Encode(privateKeyBytes)[2:]) // 0xfad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19
	//根据私钥生成公钥
    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
    }
	//打印公钥
    publicKeyBytes := crypto.FromECDSAPub(publicKeyECDSA)
    fmt.Println(hexutil.Encode(publicKeyBytes)[4:]) // 0x049a7df67f79246283fdc93af76d4f8cdd62c4886e8cd870944e817dd0b97934fdd7719d0810951e03418205868a5c1b40b192451367f28e0088dd75e15de40c05

    //根据公钥生成公共地址，方式一
    address := crypto.PubkeyToAddress(*publicKeyECDSA).Hex()
    fmt.Println(address) // 0x96216849c49358B10257cb55b28eA603c874b05E

    //根据公钥生成公共地址，方式二
    hash := sha3.NewLegacyKeccak256()
    hash.Write(publicKeyBytes[1:])
    fmt.Println(hexutil.Encode(hash.Sum(nil)[12:])) // 0x96216849c49358b10257cb55b28ea603c874b05e
}
```

### 3. 密钥库

#### 3.1 生成Keystore文件

keystore是一个包含经过加密了的钱包私钥。go-ethereum中的keystore，**每个文件只能包含一个钱包密钥对**。要生成keystore，首先您**必须调用`NewKeyStore`，给它提供保存keystore的目录路径**。然后，您可**调用`NewAccount`方法创建新的钱包**，并给它**传入一个用于加密的口令**。您**每次调用`NewAccount`，它将在磁盘上生成新的keystore文件**。

这是一个完整的生成新的keystore账户的示例。

```go
ks := keystore.NewKeyStore("./wallets", keystore.StandardScryptN, keystore.StandardScryptP)
password := "secret"   //传入一个加密口令
account, err := ks.NewAccount(password)
if err != nil {
  log.Fatal(err)
}

fmt.Println(account.Address.Hex()) // 0x20F8D42FB0F667F2E53930fed426f225752453b3
```

现在要导入您的keystore，需要再次调用`NewKeyStore`，然后调用**`Import`方法**，该方法**第一个参数接收keystore的JSON数据转换后的字节流信息**。**第二个参数是生成Account时的加密私钥口令**。**第三个参数是指定一个新的加密口令**，但我们在示例中使用一样的口令。

#### 3.2 访问Keystore文件读取Account

**导入账户**将允许您按期访问该账户，但它**将生成新keystore文件**！有两个相同的事物是没有意义的，所以我们将删除旧的。

这是一个导入keystore和访问账户的示例。

```go
file := "./wallets/UTC--2018-07-04T09-58-30.122808598Z--20f8d42fb0f667f2e53930fed426f225752453b3"
ks := keystore.NewKeyStore("./tmp", keystore.StandardScryptN, keystore.StandardScryptP)
jsonBytes, err := ioutil.ReadFile(file)   //从keystore文件中读取json字节流
if err != nil {
  log.Fatal(err)
}

password := "secret"   //访问Keystore文件中account所需的口令
account, err := ks.Import(jsonBytes, password, password)
if err != nil {
  log.Fatal(err)
}

fmt.Println(account.Address.Hex()) // 0x20F8D42FB0F667F2E53930fed426f225752453b3

if err := os.Remove(file); err != nil {   //删除旧的keystore文件
  log.Fatal(err)
}
```

#### 3.3 完整代码

```go
package main

import (
    "fmt"
    "io/ioutil"
    "log"
    "os"

    "github.com/ethereum/go-ethereum/accounts/keystore"
)

func createKs() {
    ks := keystore.NewKeyStore("./wallets", keystore.StandardScryptN, keystore.StandardScryptP)
    password := "secret"
    account, err := ks.NewAccount(password)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(account.Address.Hex()) // 0x20F8D42FB0F667F2E53930fed426f225752453b3
}

func importKs() {   //导入时，不需要使用NewAccount()方法，但需要使用NewKeyStore()方法重新创建keystore文件
    file := "./wallets/UTC--2018-07-04T09-58-30.122808598Z--20f8d42fb0f667f2e53930fed426f225752453b3"
    ks := keystore.NewKeyStore("./tmp", keystore.StandardScryptN, keystore.StandardScryptP)
    jsonBytes, err := ioutil.ReadFile(file)
    if err != nil {
        log.Fatal(err)
    }

    password := "secret"
    account, err := ks.Import(jsonBytes, password, password)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(account.Address.Hex()) // 0x20F8D42FB0F667F2E53930fed426f225752453b3

    if err := os.Remove(file); err != nil {
        log.Fatal(err)
    }
}

func main() {
    createKs()
    //importKs()
}
```

### 4. 地址检查

本节将介绍如何确认一个地址并确定其是否为智能合约地址。

#### 4.1 检查地址是否有效(仅在本地判断格式是否正确)

我们可以使用简单的**正则表达式**来**检查以太坊地址是否有效(格式是否正确)**：

```go
re := regexp.MustCompile("^0x[0-9a-fA-F]{40}$")

fmt.Printf("is valid: %v\n", re.MatchString("0x323b5d4c32345ced77393b3530b1eed0f346429d")) // is valid: true
fmt.Printf("is valid: %v\n", re.MatchString("0xZYXb5d4c32345ced77393b3530b1eed0f346429d")) // is valid: false
```

#### 4.2 检查地址是否为账户或智能合约

我们可以确定，**若在该地址存储了字节码**(**需要到以太坊访问该地址获取字节码**)，**该地址是智能合约**。这是一个示例，在例子中，我们获取一个代币智能合约的字节码并检查其长度以验证它是一个智能合约：

```go
client, err := ethclient.Dial("https://cloudflare-eth.com")
	if err != nil {
		log.Fatal(err)
	}
fmt.Println("we have a connection")

// 0x Protocol Token (ZRX) smart contract address
address := common.HexToAddress("0xe41d2489571d322189246dafa5ebde1f4699f498")
bytecode, err := client.CodeAt(context.Background(), address, nil) // nil is latest block
if err != nil {
  log.Fatal(err)
}

isContract := len(bytecode) > 0

fmt.Printf("is contract: %v\n", isContract) // is contract: true
```

当地址上没有字节码时，我们知道它不是一个智能合约，它是一个标准的以太坊账户。

```go
// a random user account address
address := common.HexToAddress("0x8e215d06ea7ec1fdb4fc5fd21768f4b34ee92ef4")
bytecode, err := client.CodeAt(context.Background(), address, nil) // nil is latest block
if err != nil {
  log.Fatal(err)
}

isContract = len(bytecode) > 0

fmt.Printf("is contract: %v\n", isContract) // is contract: false
```

#### 4.3 完整代码

```go
package main

import (
    "context"
    "fmt"
    "log"
    "regexp"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    re := regexp.MustCompile("^0x[0-9a-fA-F]{40}$")

    fmt.Printf("is valid: %v\n", re.MatchString("0x323b5d4c32345ced77393b3530b1eed0f346429d")) // is valid: true
    fmt.Printf("is valid: %v\n", re.MatchString("0xZYXb5d4c32345ced77393b3530b1eed0f346429d")) // is valid: false

    client, err := ethclient.Dial("https://cloudflare-eth.com")
    if err != nil {
        log.Fatal(err)
    }

    // 0x Protocol Token (ZRX) smart contract address
    address := common.HexToAddress("0xe41d2489571d322189246dafa5ebde1f4699f498")
    bytecode, err := client.CodeAt(context.Background(), address, nil) // nil is latest block
    if err != nil {
        log.Fatal(err)
    }

    isContract := len(bytecode) > 0

    fmt.Printf("is contract: %v\n", isContract) // is contract: true

    // a random user account address
    address = common.HexToAddress("0x8e215d06ea7ec1fdb4fc5fd21768f4b34ee92ef4")
    bytecode, err = client.CodeAt(context.Background(), address, nil) // nil is latest block
    if err != nil {
        log.Fatal(err)
    }

    isContract = len(bytecode) > 0

    fmt.Printf("is contract: %v\n", isContract) // is contract: false
}
```

## 三、访问交易信息

### 1. 查询区块

正如我们所见，您可以有两种方式查询区块信息。

#### 1.1 只查询区块头

您可以调用客户端的`HeaderByNumber`来**返回有关一个区块的头信息**。**若传入`nil`，它将返回最新的区块头**。

```go
header, err := client.HeaderByNumber(context.Background(), nil)
if err != nil {
  log.Fatal(err)
}

fmt.Println(header.Number.String()) // 5671744
```

#### 1.2 查询完整区块

调用客户端的`BlockByNumber`方法来获得完整区块。您可以读取该区块的所有内容和元数据，例如，区块号，区块时间戳，区块摘要，区块难度以及交易列表等等。

```go
blockNumber := big.NewInt(5671744)
block, err := client.BlockByNumber(context.Background(), blockNumber)
if err != nil {
  log.Fatal(err)
}

fmt.Println(block.Number().Uint64())     // 5671744
fmt.Println(block.Time())       // 1527211625
fmt.Println(block.Difficulty().Uint64()) // 3217000136609065
fmt.Println(block.Hash().Hex())          // 0x9e8751ebb5069389b855bba72d94902cc385042661498a415979b7b6ee9ba4b9
fmt.Println(len(block.Transactions()))   // 144
```

调用Transaction只**返回一个区块的交易数目**。

```go
count, err := client.TransactionCount(context.Background(), block.Hash())  //根据区块哈希查询
if err != nil {
  log.Fatal(err)
}

fmt.Println(count) // 144
```

#### 1.3 完整代码

```go
package main

import (
    "context"
    "fmt"
    "log"
    "math/big"

    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://cloudflare-eth.com")
    if err != nil {
        log.Fatal(err)
    }

    header, err := client.HeaderByNumber(context.Background(), nil)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(header.Number.String()) // 5671744

    blockNumber := big.NewInt(5671744)
    block, err := client.BlockByNumber(context.Background(), blockNumber)  //返回一个区块对象实体
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(block.Number().Uint64())     // 5671744
    fmt.Println(block.Time())       // 1527211625
    fmt.Println(block.Difficulty().Uint64()) // 3217000136609065
    fmt.Println(block.Hash().Hex())          // 0x9e8751ebb5069389b855bba72d94902cc385042661498a415979b7b6ee9ba4b9
    fmt.Println(len(block.Transactions()))   // 144

    count, err := client.TransactionCount(context.Background(), block.Hash())
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(count) // 144
}
```

### 2. 查询区块内交易

#### 2.1 获取区块内交易的具体内容

在[上个章节](https://goethereumbook.org/zh/block-query) 我们学习了如何在给定区块编号的情况下读取块及其所有数据。 我们可以通过**调用`Transactions`方法来读取块中的事务**，该方法**返回一个`Transaction`类型的列表**。 然后，重复遍历集合并获取有关事务的任何信息就变得简单了。

```go
for _, tx := range block.Transactions() {
  fmt.Println(tx.Hash().Hex())        // 0x5d49fcaa394c97ec8a9c3e7bd9e8388d420fb050a52083ca52ff24b3b65bc9c2
  fmt.Println(tx.Value().String())    // 10000000000000000
  fmt.Println(tx.Gas())               // 105000
  fmt.Println(tx.GasPrice().Uint64()) // 102000000000
  fmt.Println(tx.Nonce())             // 110644
  fmt.Println(tx.Data())              // []
  fmt.Println(tx.To().Hex())          // 0x55fE59D8Ad77035154dDd0AD0388D09Dd4047A8e
}
```

#### 2.2 获取交易sender地址

为了读取**交易发送方的地址**，我们需要**在tx上调用`AsMessage()`方法**，它**返回一个`Message`类型**，其中**包含一个返回sender（from）地址的函数**。 `AsMessage`方法**需要EIP155签名者，这个我们从客户端拿到链ID**。

```go
chainID, err := client.NetworkID(context.Background())
if err != nil {
  log.Fatal(err)
}

if msg, err := tx.AsMessage(types.NewEIP155Signer(chainID)); err == nil {
  fmt.Println(msg.From().Hex()) // 0x0fD081e3Bb178dc45c0cb23202069ddA57064258
}
```

此处有两点需要注意：

```go
1.使用的types包需要引用自"github.com/ethereum/go-ethereum/core/types"，而不是"github.com/FISCO-BCOS/go-sdk/core/types"。经测试vscode会自动引用后者，需要使用者自动进行修改

2.client.NetworkID(context.Background())函数会报错，原因是以太坊给出的 NetworkID方法 源码存在问题:
func (ec *Client) NetworkID(ctx context.Context) (*big.Int, error) {
    version := new(big.Int)
	var ver string      //存在问题，需要修改为int类型  
	if err := ec.c.CallContext(ctx, &ver, "net_version"); err != nil {
		return nil, err
	}
    if _, ok := version.SetString(ver, 10); !ok {   //此处的ver应该修改为:fmt.Sprintf("%d", ver)
		return nil, fmt.Errorf("invalid net_version result %q", ver)
	}
	return version, nil
}
```

#### 2.3 根据交易hash获取交易的收据

每个tx都有一个收据，其中包含执行tx的结果，例如任何返回值和日志，以及为“1”（成功）或“0”（失败）的事件结果状态。

```go
receipt, err := client.TransactionReceipt(context.Background(), tx.Hash())
if err != nil {
  log.Fatal(err)
}

fmt.Println(receipt.Status) // 1
fmt.Println(receipt.Logs) // ...
```

#### 2.4 根据块Hash和交易索引值获取交易

在不获取块的情况下遍历交易的另一种方法是**调用客户端的TransactionInBlock方法**。 此方法仅**接受块哈希和块内交易的索引值**。 您可以**调用TransactionCount来了解块中有多少笔交易**。

```go
blockHash := common.HexToHash("0x9e8751ebb5069389b855bba72d94902cc385042661498a415979b7b6ee9ba4b9")
count, err := client.TransactionCount(context.Background(), blockHash)  //根据区块hash获取块内交易数目
if err != nil {
  log.Fatal(err)
}

for idx := uint(0); idx < count; idx++ {   //根据区块hash和交易索引值获取一笔交易
  tx, err := client.TransactionInBlock(context.Background(), blockHash, idx)
  if err != nil {
    log.Fatal(err)
  }

    fmt.Println(tx.Hash().Hex()) //打印每一笔tx的hash值(十六进制字符串形式)
}
```

#### 2.5 根据交易hash直接获取交易

您还可以使用`TransactionByHash`在给定具体交易哈希值的情况下**直接查询单个交易**。

```go
txHash := common.HexToHash("0x5d49fcaa394c97ec8a9c3e7bd9e8388d420fb050a52083ca52ff24b3b65bc9c2")
tx, isPending, err := client.TransactionByHash(context.Background(), txHash)
if err != nil {
  log.Fatal(err)
}

fmt.Println(tx.Hash().Hex()) // 0x5d49fcaa394c97ec8a9c3e7bd9e8388d420fb050a52083ca52ff24b3b65bc9c2
fmt.Println(isPending)       // false
```

2.6 完整代码

```go
package main

import (
    "context"
    "fmt"
    "log"
    "math/big"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://cloudflare-eth.com")
    if err != nil {
        log.Fatal(err)
    }

    // 1.根据区块编号直接获取区块实体
    blockNumber := big.NewInt(5671744)
    block, err := client.BlockByNumber(context.Background(), blockNumber)
    if err != nil {
        log.Fatal(err)
    }
	// 2.使用区块的Transactions()获取交易列表，可以访问交易对象tx的各项信息
    for _, tx := range block.Transactions() {
        fmt.Println(tx.Hash().Hex())        // 0x5d49fcaa394c97ec8a9c3e7bd9e8388d420fb050a52083ca52ff24b3b65bc9c2
        fmt.Println(tx.Value().String())    // 10000000000000000
        fmt.Println(tx.Gas())               // 105000
        fmt.Println(tx.GasPrice().Uint64()) // 102000000000
        fmt.Println(tx.Nonce())             // 110644
        fmt.Println(tx.Data())              // []
        fmt.Println(tx.To().Hex())          // 0x55fE59D8Ad77035154dDd0AD0388D09Dd4047A8e
		// 3.获取每笔交易tx的sender的地址以及交易的收据receipt
        chainID, err := client.NetworkID(context.Background())
        if err != nil {
            log.Fatal(err)
        }
		// 获取交易的sender的address
        if msg, err := tx.AsMessage(types.NewEIP155Signer(chainID)); err == nil {
            fmt.Println(msg.From().Hex()) // 0x0fD081e3Bb178dc45c0cb23202069ddA57064258
        }
		// 获取交易的收据
        receipt, err := client.TransactionReceipt(context.Background(), tx.Hash())
        if err != nil {
            log.Fatal(err)
        }

        fmt.Println(receipt.Status) // 1--成功的交易  0--失败的交易
    }
	// 3.根据区块hash获取和交易索引值获取交易对象
    blockHash := common.HexToHash("0x9e8751ebb5069389b855bba72d94902cc385042661498a415979b7b6ee9ba4b9")
    count, err := client.TransactionCount(context.Background(), blockHash)  //区块内交易数目
    if err != nil {
        log.Fatal(err)
    }
	// 根据索引值访问每笔交易
    for idx := uint(0); idx < count; idx++ {
        tx, err := client.TransactionInBlock(context.Background(), blockHash, idx)
        if err != nil {
            log.Fatal(err)
        }

        fmt.Println(tx.Hash().Hex()) // 0x5d49fcaa394c97ec8a9c3e7bd9e8388d420fb050a52083ca52ff24b3b65bc9c2
    }
	// 4.根据交易hash值直接访问交易
    txHash := common.HexToHash("0x5d49fcaa394c97ec8a9c3e7bd9e8388d420fb050a52083ca52ff24b3b65bc9c2")
    tx, isPending, err := client.TransactionByHash(context.Background(), txHash)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(tx.Hash().Hex()) // 0x5d49fcaa394c97ec8a9c3e7bd9e8388d420fb050a52083ca52ff24b3b65bc9c2
    fmt.Println(isPending)       // false
}
```

## 四、ETH 转账

学习如何将ETH从一个帐户转移到另一个帐户。一笔交易包括打算转账的以太币数量，燃气限额，燃气价格，一个随机数(nonce)，接收地址以及可选择性的添加的数据。 在广告发送到网络之前，必须使用发送方的私钥对该交易进行签名。

### 1. 加载本地的私钥

假设您已经连接了客户端，下一步就是加载您的私钥。

```go
//1.加载已有的私钥
privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
if err != nil {
  log.Fatal(err)
}
//2.使用新生成的私钥
privateKey, err := crypto.GenerateKey() //生成私钥
	if err != nil {
		log.Fatal(err)
	}
```

### 2. 设置交易的nonce

之后我们需要获得帐户的随机数(nonce)。 每笔交易都需要一个nonce。 根据定义，**nonce是仅使用一次的数字**。  如果是发送交易的**新帐户，则该随机数将为“0”**。  来自帐户的**每个新交易都必须具有前一个nonce增加1的nonce**。很难对所有nonce进行手动跟踪，于是**ethereum客户端提供一个帮助方法`PendingNonceAt`，它将返回你应该使用的下一个nonce**。

该函数需要我们发送的帐户的公共地址 - 这个我们可以从私钥派生。

```go
publicKey := privateKey.Public()
publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
if !ok {
  log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
}

fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
```

接下来我们可以读取我们应该用于帐户交易的随机数。

```go
nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
if err != nil {
  log.Fatal(err)
}
```

### 3. 设置要转移的ETH数

下一步是设置我们将要转移的ETH数量。 但是我们**必须将ETH以太转换为wei**，因为这是以太坊区块链所使用的。 **以太网支持最多18个小数位，因此1个ETH为1加18个零**。

 这里有一个小工具可以帮助您在ETH和wei之间进行转换: https://etherconverter.netlify.com

```go
value := big.NewInt(1000000000000000000) // in wei (1 eth)
```

### 4. 设置燃油上限和燃油价格

#### 4.1 设置燃油上限

ETH转账的燃气应设上限为“21000”单位**(不同操作消耗的燃油单位不同)**。

```go
gasLimit := uint64(21000) // in units
```

#### 4.2 设置燃油费(单个燃油单位的价格)

**燃气价格必须以wei为单位设定**。 在撰写本文时，将在一个区块中比较快的打包交易的燃气价格为30 gwei。

```go
gasPrice := big.NewInt(30000000000) // in wei (30 gwei)
```

然而，**燃气价格总是根据市场需求和用户愿意支付的价格而波动的**，因此对燃气价格进行硬编码有时并不理想。 go-ethereum客户端提供**`SuggestGasPrice`函数，用于根据'x'个先前块来获得平均燃气价格**。

```go
gasPrice, err := client.SuggestGasPrice(context.Background())
if err != nil {
  log.Fatal(err)
}
```

### 5. 设置目的账户地址

接下来我们弄清楚我们将ETH发送给谁。

```go
toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")
```

### 6. 生成交易

现在我们最终可以通过导入go-ethereum`core/types`包并**调用`NewTransaction`来生成我们的未签名以太坊交易**，这个函数需要**接收nonce，地址，转账的ETH数，燃气上限值，燃气价格和可选发送的数据**。 发送ETH的数据字段为“nil”。 在**与智能合约进行交互时，我们将使用数据字段，仅仅转账以太币是不需要数据字段的。**

```go
tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, nil)
```

### 7. 发送者对交易签名

下一步是**使用发件人的私钥对交易进行签名**。 为此，我们调用`SignTx`方法，该方法接受一个未签名的事务和我们之前构造的私钥。 `SignTx`方法需要EIP155签名者，这个也需要我们先从客户端拿到链ID。

```go
chainID, err := client.NetworkID(context.Background())
if err != nil {
  log.Fatal(err)
}

signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
if err != nil {
  log.Fatal(err)
}
```

### 8. 将交易广播上链

现在我们终于准备通过在客户端上**调用“SendTransaction”来将已签名的交易广播到整个网络**。

```go
err = client.SendTransaction(context.Background(), signedTx)
if err != nil {
  log.Fatal(err)
}

fmt.Printf("tx sent: %s", signedTx.Hash().Hex()) // tx sent: 0x77006fcb3938f648e2cc65bafd27dec30b9bfbe9df41f78498b9c8b7322a249e
```

可以去Etherscan看交易的确认过程:  https://rinkeby.etherscan.io/tx/0x77006fcb3938f648e2cc65bafd27dec30b9bfbe9df41f78498b9c8b7322a249e

### 9. 完整代码

```go
package main

import (
    "context"
    "crypto/ecdsa"
    "fmt"
    "log"
    "math/big"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/crypto"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://rinkeby.infura.io")
    if err != nil {
        log.Fatal(err)
    }

    privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
    if err != nil {
        log.Fatal(err)
    }

    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
    }

    fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
    nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
    if err != nil {
        log.Fatal(err)
    }

    value := big.NewInt(1000000000000000000) // in wei (1 eth)
    gasLimit := uint64(21000)                // in units
    gasPrice, err := client.SuggestGasPrice(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")
    var data []byte
    tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data)

    chainID, err := client.NetworkID(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
    if err != nil {
        log.Fatal(err)
    }

    err = client.SendTransaction(context.Background(), signedTx)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("tx sent: %s", signedTx.Hash().Hex())
}
```

## 五、订阅新区块

### 1. 订阅流程

在本节中，我们将讨论如何**设置订阅以便在新区块被开采时获取事件(也就是获取这个新产生的区块)**。首先，我们**需要一个支持websocket RPC的以太坊服务提供者**。在示例中，我们将使用infura 的websocket端点。

```go
client, err := ethclient.Dial("wss://ropsten.infura.io/ws")
if err != nil {
  log.Fatal(err)
}
```

接下来，我们将**创建一个新的通道，用于接收最新的区块头。**

```go
headers := make(chan *types.Header)
```

现在我们**调用客户端的`SubscribeNewHead`方法**，它**接收我们刚创建的区块头通道**，该方法将**返回一个订阅对象**。

```go
sub, err := client.SubscribeNewHead(context.Background(), headers)
if err != nil {
  log.Fatal(err)
}
```

**订阅将推送新的区块头事件到我们的通道**，因此我们可以**使用一个select语句来监听新消息**。订阅对象还包括一个error通道，该通道将在订阅失败时发送消息。

```go
for {
  select {
  case err := <-sub.Err():
    log.Fatal(err)
  case header := <-headers:
    fmt.Println(header.Hash().Hex()) // 0xbc10defa8dda384c96a17640d84de5578804945d347072e091b4e5f390ddea7f
  }
}
```

要**获得该区块的完整内容**，我们可以**将区块头的摘要传递给客户端的`BlockByHash`函数**。

```go
block, err := client.BlockByHash(context.Background(), header.Hash())
if err != nil {
  log.Fatal(err)
}

fmt.Println(block.Hash().Hex())        // 0xbc10defa8dda384c96a17640d84de5578804945d347072e091b4e5f390ddea7f
fmt.Println(block.Number().Uint64())   // 3477413
fmt.Println(block.Time().Uint64())     // 1529525947
fmt.Println(block.Nonce())             // 130524141876765836
fmt.Println(len(block.Transactions())) // 7
```

### 2. 完整代码

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("wss://ropsten.infura.io/ws")
    if err != nil {
        log.Fatal(err)
    }

    headers := make(chan *types.Header)
    sub, err := client.SubscribeNewHead(context.Background(), headers)
    if err != nil {
        log.Fatal(err)
    }

    for {
        select {
        case err := <-sub.Err():
            log.Fatal(err)
        case header := <-headers:
            fmt.Println(header.Hash().Hex()) // 0xbc10defa8dda384c96a17640d84de5578804945d347072e091b4e5f390ddea7f

            block, err := client.BlockByHash(context.Background(), header.Hash())
            if err != nil {
                log.Fatal(err)
            }

            fmt.Println(block.Hash().Hex())        // 0xbc10defa8dda384c96a17640d84de5578804945d347072e091b4e5f390ddea7f
            fmt.Println(block.Number().Uint64())   // 3477413
            fmt.Println(block.Time().Uint64())     // 1529525947
            fmt.Println(block.Nonce())             // 130524141876765836
            fmt.Println(len(block.Transactions())) // 7
        }
    }
}
```

