### 一、点与边的表示

#### 1.1 点

```go
type Node struct {
    value interface{}  // 该点存储的值
    in int  // 该点的入度
    out int // 该点的出度
    nexts []Node  // 所有由当前点发散出去的直接邻居节点
    edges []Edge  // 所有由当前节点发散出去的边
}
```

#### 1.2 边

```go
type Edge struct {
    weight int  // 该边的权重
    from Node   // 起点
    to Node		// 终点
}
```

### 二、图的表示

图的表示方法各种各样，因此导致有关图的题解法多种多样。但是只要掌握其中一种图的解题方法，遇到其他表示方法可以直接先将其他表示方法转化为当前的表示方法，然后再进行解题即可。

#### 2.1 将二维数组转化为图

一个二维数组表示的图如下：

```go
[
    [0,1,5],  // 表示有一条从0到1的权重为5的边
    [1,2,3],
    ………………
]
```

图的数据结构如下：

```go
type Graph struct {
    node map[interface{}]Node
    Edges map[Edge]struct{} 
}
```



```go
func createGraph([][]matrix int) Graph {
    graph := new(Graph)
    for i:=0;i<len(matrix);i++{
        from := matrix[i][0]
        to := matrix[i][1]
        weight := matrix[i][2]
        
        if fromNode,ok:=graph.nodes[from];!ok{
            graph.nodes[from] = Node{value:from}
        }
        if toNode,ok:=graph.nodes[to];!ok{
            graph.nodes[to] = Node{value:to}
        }
        
        fromNode := graph.nodes[from]
        toNode := graph.nodes[to]
        newEdge := Edge{weight:weight,from:from,to:to}
        
        fromNode.nexts = append(fromNode.nexts,toNode)
        fromNode.out++
        toNode.in++
        fromNode.edges = append(fromNode.edges,newEdge)
        graph.edges = append(graph.edges,newEdge)
    }
}
```

### 三、图的遍历

#### 3.1 宽度优先遍历

流程如下：

1. 利用队列实现
2. 从源节点开始进队列，然后弹出
3. 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
4. 直到队列变空

```go
func bfs(node Node) {
    if node == nil {
        return
    }
    queue := new(Queue)
    set := make(map[Node]struct{},0)
    
    // 将当前节点放入queue和set中
    queue.Add(node)
    set[node] = struct{}   // set的作用是防止环导致的死循环问题(不能将重复的元素进行处理)
    
    for {
        if queue.IsEmpty() {
            return
        }
        curNode := queue.Poll() // 出队列一个节点
        fmt.Println(curNode.value) // 出队列的时候对节点进行处理
        
        // 将当前节点的所有set未见过的邻居节点加入到queue和set中
        for _,node := range curNode.nexts{
            if _ok := set[node];ok{
                continue
            }else {
                set[node] = struct{}
                queue.Add(node)
            }
        }
    }
}
```



#### 3.2 深度优先遍历

流程如下：

1. 利用栈实现
2. 从源节点开始依次进栈，然后弹出
3. 每弹出一个点，如果遇到没有进过栈的邻接点。先将节点本身再次入栈，再将该邻居节点入栈
4. 直到栈变空

```go
func dfs(node Node) {
    if node == nil{
        return
    }
    stack := new(Stack)
    set := make(map[Node]struct{},0)
    
    stack.Add(node)  // 入栈
    set[node] = struct{}  // set进行记录
    fmt.Println(node.value)  // 入栈时进行处理
    
    for {
        if stack.IsEmpty() {
            return
        }
        curNode := stack.pop()  // 节点出栈
        for _,next := range curNode.nexts {
            if _,ok := set[next];!ok{  // 邻居节点尚未被遍历
                stack.Push(curNode)  // 当前节点再次入栈
                stack.Push(next)  // 邻居节点入栈
                set[next] = struct{}  // set进行记录
                fmt.Println(next.value)
                break  // 直接break，不再继续处理当前节点的其他邻居节点。作用是保留当前深度搜索路径。
            }
        }
    }
}

注：dfs算法中，栈始终保留当前深度搜索的路径。当整个图遍历完成之和，整个搜索路径上的节点统一出栈，结束遍历。
```

#### 3.3 拓扑遍历

这种遍历方式，是针对于有向无环图的遍历。常见于工程项目中的包依赖编译过程。

假设工程A依赖于B、C、D包的编译(import引用了这些包)，而B又依赖于C、D、E包，因此编译器需要一种编译顺序来完成工程A的编译，而这种顺序就是使用拓扑遍历方式完成。

> 思路：
>
> 由于针对的是有向无环图。因此一定存在一个入度为零的点。因此，遍历方式如下：
>
> 1. 找到第一个入度为零的点，存储保留，然后将该节点以及相连的边从图中删除
> 2. 再次寻找入度为零的新点，存储保留，然后将该节点以及相连的边从图中删除
> 3. 重复步骤二，直到原图找不到任何新节点。

 ```go
 func sortTopology(graph Graph) []Node {
     inMap := make(map[Node]int,0)   // 存储每一个Node的剩余入度
     zeroInQueue := new(Queue)  // 存储所有入度为零的节点
     
     // 初始化操作，将所有节点准确的入度进行保留，并获取第一批入度为零的节点
     for _,node := range graph.nodes {
         inMap[node] = node.in
         if node.in == 0{
             zeroInQueue.Add(node)
         }
     }
     // 进行拓扑排序(遍历)
     result :=  make([]Node,0)  // 最终返回完成拓扑排序的Node集合
     for {
         if zeroInQueue.IsEmpty() {
             return
         }
         // 将入度为0的节点出队列，并保存到返回结果中
         curNode := zeroInQueue.Poll()
         result  = append(result,curNode)
         
         // 删除边的操作，直接以减小入度的方式进行体现
         for _,next := range curNode.nexts {
             inMap[next,inMap[next]-1]
             if inMap[next] == 0{
                 zeroInQueue.Add(next)
             }
         }
     }
     return result
 }
 ```

### 四、求最小生成树

​	最小代价的无环连通图

#### 4.1 克鲁斯卡尔算法(`Kruskal`)

> 思路：从最小的边开始，如果加上这条边没有形成环那么就加上，否则不加这条边。因此问题的重点在于：如何判断当前图有没有形成环。

> 如何判断当前图是否形成环？
>
> 可以将整个图分为两个集合：集合一和集合二。集合一开始只包含开始节点，集合二包含除了开始节点之外的图上的其他所有点。
>
> 然后每加入一条最小边，先判断此边链接的点是否已经存在于集合一，如果已经存在说明构成了环；否则无环，无环就可以将点从集合二移至集合一。

```go
type MySet struct {
    setMap map[Node][]Node
}
// 每一个node节点都维护属于自己的set集合(该set集合表示节点所在的节点集合)
func NewMySets(nodes []Node) {
    for _,node := range nodes {
        set := make([]Node,0)
        set = append(set,node)
        setMap[node] = set
    }
}

// 判断一条边的from点和to点是否位于同一个节点集合中
func (ms *MySet) isSameSet(from,to Node) bool {
    fromSet := setMap[from]
    toSet := setMap[to]
    return fromSet == toSet  // 根据地址来判断是否是同一个集合
}

// 将from点和to点归到一个节点集合中
func (ms *MySet) union(from,to Node) {
    fromSet := setMap[from]
    toSet := setMap[to]
    
    // toSet归并到fromSet中
    for _,toNode := range toSet {
        fromSet = append(fromSet,toNode)
        setMap[toNode] = fromSet
    }
}
```

使用上述类完成 克鲁斯卡尔算法。

```go
func kruskalMST(graph Graph) {
    myset := new(MySet)
    myset = NewMySets(graph.node)
    
    // 自定义排序，将边集从小到大排序,生成排序后的队列priorityQueue
    ………………
    
    result := make([]Edge,0)
    for {
        if priorityQueue.IsEmpty() {
            break
        }
        edge := priorityQueue.Poll()
        // 如果边的两端点不在同一集合中，则将改变导入最后的返回结果中
        if !myset.isSameSet(edge.from,edge.to) {
            result.add(edge)
            // 合并两端点到同一个节点集合中
            myset.union(edge.from,edge.to)
        }
    }
    return result
}
```

#### 4.2 普利姆算法(`Prim`)

普利姆算法的思想是：每次循环挑一个节点加入到已读点集合，当已读点集合囊括了原集合全部元素就结束。具体的：

1. 随机挑选一个节点将其加入已读点集合，获取其所有边，将此边集合按照从小到大的顺序放到公共的边队列（**该队列在插入元素时必须按照大小顺序进行插入**）中
2. 每次从公共队列中取出一条边(必然最小)。如果该边的`to`节点不在已读点集合中则将该节点加入到已读点集合；否则无视此节点。
3. 对于新加入到已读点集合的新节点，获取其所有边，将此边集合按照从小到大的顺序放到公共的边队列中。重复步骤二。

```go
func primMST(graph Graph) map[Edge]struct{} {
    
    // 按照从大到小对边进行存储的队列
    priorityQueue := new(priorityQueue)
    // 已读节点集合
    set := make(map[Node]struct{})
    // 已读边集合
    result := make(map[Edge]struct{})
    
    // 随便挑一个节点，防止森林出现导致的节点依次遍历读不完的情况
    for _,randomNode := range graph.nodes {
        // 如果节点不在已读点集合中，则继续
        if _,ok := set[randomNode];!ok {
            set[Node] = struct{}
            // 由一个点，解锁所有相连的边
            for _,edge := range randomNode.edges {
                priorityQueue.add(edge) 
            }
            
            for {
                if priorityQueue.IsEmpty() {
                    break
                }
                edge := priorityQueue.poll() // 取最小的边
                toNode := edge.to  // 可能的新点
                // 该to点不在已读点集合中，则继续
                if _,ok := set[toNode];!ok{
                    set[toNode] = struct{}
                    result[edge] = struct{}
                    
                    // 将新加入点的所有边插入到priorityQueue
                    for _,newEdge := range toNode.edges {
                        priorityQueue.add(newEdge)
                    }
                }
            }
        }
    }
    return result
}
```

### 五、最短路径

​	求图中任意两点的最短路径

#### 5.1 迪克斯特拉算法（`Dijkstra`）

​	适用于没有加权为负数的环（可以有为负值的边，但是不能有负数环）

​	对于随机选择的一个起点，可以计算出该点到图中任意一点的最短路径

> 思路：
>
> 1. 对于选择的起点A，起始时刻他到各点的距离都是∞，到自己的距离是0。选一个距离起点最小的点添加到已读点集合，这里就是起点A自己。
> 2. 第一步，获取起点的所有邻边，重新更新到各点的最短距离（只有比之前小，才会进行更新）。选出距离其最近的一个点B，将其添加到已读点集合（当然，点不能已经在已读点集合中）
> 3. 第二步，从B出发，获取B的所有邻边，重新更新到各点的最短距离。选出一个距离B最近的点C，将其添加到已读点集合
> 4. 重复步骤二，直到无法加入新的点到已读点集合。