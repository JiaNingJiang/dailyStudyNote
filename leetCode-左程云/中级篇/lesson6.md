## 一、强关系表达式问题的求解

### 1. 斐波那契数列

我们知道斐波那契数列的求解关系表达式是固定的（也就是强关系表达式）：

F(1) = F(2) = 1 作为初始条件    F(N) = F(N-1) + F(N-2) (N>=2)

```
根据线性代数，对于强关系表达式可以化为以下求解方式：
						  |a  b|
|F(3) F(2)| = |F(1) F(0)|*|c  d|    // 因为 N 需要借助 N-1和N-2两个状态量，因此系数矩阵是 2*2

						  |a  b|
|F(4) F(3)| = |F(2) F(1)|*|c  d|

四个系数可以通过4个表达式求解：
a = b = c = 1 , d = 0

因此任意的：（系数矩阵直接用Factor表示）
|F(N) F(N-1)| = |F(2) F(1)| * Factor^(N-2)   //因此求解斐波那契数列问题，就变成了求系数矩阵的N-2次幂的问题
```



```
针对求解一个数的N次幂，可以用如下的方式：
假设要求10^73 == ? 可以将73拆分为2的幂的组成形式：73 = 64 + 8 + 1 
因此 10^73 = 10^64 * 10^8 * 10^1 
1）我们让 t 从10^1开始，t = 10^1 。因为存在于10^73组成公式中，因此sum+=10^1。
2）t = t * t ,因此t = 10^2 不在组成公式中(用73的二进制检查是否在组成公式中)，跳过
3) 重复，直到最大的 10^64

通过上述的方式，求解一个数的N次幂，时间复杂度就只是 O(logN) 级别，远远优于O(N)
```



## 2.类推

假设有一问题的强关系表达式为 :  F(N) = 3 * F(N-1) + 2 * F(N-3) + 5 * F(N-5)

那么求解的策略如下：

```
|F(6) F(5) F(4) F(3) F(2)| = |F(5) F(4) F(3) F(2) F(1)| * |5*5矩阵|
根据这样的列举，我们可以求出这个 5*5 矩阵

|F(N) F(N-1) F(N-2) F(N-3) F(N-4)| = |F(5) F(4) F(3) F(2) F(1)| * |5*5矩阵|^(N-5)
只需要获得 |5*5矩阵|^(N-5) 就可以得到任意的 F(N)
```



## 3.奶牛问题

假设有一个牧场，现在只有一头3岁的母牛。

通过人工授精的方式每年让所有年龄 >= 3的母牛生出一只新母牛。假设所有的牛都不会死。

求N年后牧场有多少只母牛？

```go
起始时，F(0) = 1  A
第一年：F(1) = 1+1 = 2  A B(A)
第二年：F(2) = 2+1 = 3  A B(A) C(A)
第三年：F(3) = 3+1 = 4  A B(A) C(A) D(A)
第四年：F(4) = 4+2 = 6  A B(A) C(A) D(A) E(A) F(B)   // B刚好三岁，可以生出新的母牛
……………………

计算公式 F(N) = F(N-1) + F(N-3)  // F(N-1)表示前一年剩余的牛都存活的数量  F(N-3)表示新生牛数量 == 三年前的牛的数量

|F(3) F(2) F(1)| = |F(2) F(1) F(0)| * |3*3矩阵|
求出这个 |3*3矩阵| 矩阵，假设为Factor

|F(N) F(N-1) F(N-2)| = |F(2) F(1) F(0)| * |3*3矩阵|^(N-2)
```



进阶：假设一只牛只能活10年，求N年后牧场有多少只奶牛？

```go
F(N) = F(N-1) + F(N-3) - F(N-10)   // 减去10年前的奶牛数即可
```

## 二、题目二

字符串只有  '0'  和  '1'  两种字符构成，

当字符串长度为1时，所有可能的字符串位"0"、“1”

当字符串长度为2时，所有可能的字符串位"00"、“01”、“10”、“11”

当字符串长度为3时，所有可能的字符串位"000"、“001”、“010”、“011”、“100”、“101”、“110”、“111”

………………

如果某一字符串中，只要出现'0'的位置，左边就靠着'1'，这样的字符串叫做达标字符串。

给定一个正数N，返回所有长度为N的字符串中，达标字符串的数量。

比如，N=3，返回3，因为只有"101"、“110”、“111”达标。

```go
假设字符串总长度为i，求解达标字符串数量的函数为 F(i) 
要想成为达标字符串，那么第1位必然只能是1。

对于第二位，有如下规则：
1.可以是1，如果第二位是1，那么剩余数量字符可以构成的达标字符串的数量完全等于 F(i-1)
2.可以是0，如果第二位是0，这是F(i-1)不曾有的场景(因为F(i-1)中i-1长度字符串首位必须是1，这里反而是让i-1长度字符串的首位是0)。
那么下一位固定地必须是1，此时剩余字符可以构成的达标字符串的数量完全等于 F(i-2)

所以，F(i) = F(i-1) + F(i-2)  // F(i-1)表示继承i-1长度时达标字符串的个数,因为在左边加一个1不会使已有达标字符串失效; F(i-2)则表示因为左侧多加了一个1，导致原本i-1长度字符串首位可以是0，因此前两位固定为10的情况下，剩余长度字符串达标字符串个数则是继承F(i-2) 

很明显，这是一个斐波那契数列，只是初始条件 F(1) = 1 , F(2) = 2

此问题的时间复杂度就是 O(logN) ,与暴力尝试的 O(2^N*N)相比，明显优化非常大
```



## 三、题目三

在草原上，小红捡到了n根木棍，第i根木棍的长度为i，她从中选出其中的三根木棍组成三角形。

现在小明想去掉一些木棍，使得小红任意选三根木棍都不能组成三角形。

请问小明最少去掉多少根木棍？

```go
现在有 1,2,3,4,……,n 这n根不同长度的木棍。
计算位于 1~n 这个范围内的斐波那契数列，出现的斐波那契数列以外的木棍都去掉，即为去掉最少得木棍

木棍：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 
斐波那契数列：1 1 2 3 5 8 13 21

保留的木棍：1 2 3 5 8 13 
去掉的木棍：4 6 7 9 10 11 12 14 15 16 17
```



## 四、题目四

牛牛准备参加学校组织的春游，出发前牛牛准备往背包里装入一些零食，牛牛的背包容量为w

牛牛家里一共有n袋零食，第i袋零食体积为 v[i]

牛牛想知道在总体积**不超过背包容量**的情况下，他一共有多少种零食放法（总体积为0也算一种放法）。

``` go
可以用递归法和动态规划解决：
递归法: 遍历v[]零食体积数组，每一轮遍历都可以分为 要v[i]和不要v[i] 两种情况

动态规划：（二维表根据最后一行向上求解，最后返回dp[0][0]作为返回值）
1.初始条件 dp[n-1][weight] = 1 (weight <= w )  dp[n-1][weight] = 1 (weight > w )
2. dp[i][j] = dp[i+1][j] + dp[i+1][j-v[i]] 

```



## 五、题目五

为了找到满意的工作，牛牛收集到了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴来找牛牛帮忙选工作。

给定一个Job结构体（包括工作难度hard和工作报酬money）数组jobarr，再给定一个int类型的数组arr，表示所有小伙伴的能力。

返回一个int型数组，表示每一个小伙伴按照牛牛的标准选工作后能获得的报酬。

```go
1.先对jobarr按照工作难度hard从小到大排序。
2.工作难度hard相等的归为一组，组内按照报酬money从大到小排序，只保留每一种money最多的job
3.剩余的jobarr数组元素，再从小到大遍历，因为工作难度hard必然是递增的，所以一旦遇到报酬money小于前一项的，直接将该job移出。
4.最后jobarr中的元素：按照hard从小到大，按照money从小到大。每个人只需要选择最接近自己能力的hard的job即可。


```



## 六、题目六

现在有一个数字字符串，需要将其转化为int型数值，请问如何操作？

```go
1.无论字符串表示的是正整数还是负整数，统一转换为负整数（因为负整数个数比正整数多一个）
2.假设字符串为“-1023”，转换过程为:
0 + (-1) = -1  (-1)*10 +(-0) = -10  -10*10+(-2) = -102   -102*10+(-3) = -1023

func Convert(str string) int {
    neg := str[0] == '-'?true:false
    minq := math.MinInt/10
    minr := math.MinInt%10
    var res int = 0
    var cur int = 0
    var start int = 0
    if neg {
        start++
    }
    for i:=start;i<len(str);i++ {
        cur = '0' - str[i]  // 获取负数
        // 中途转化过程中，出现溢出(在下一轮的res*10会溢出或者在 +res 时会溢出)
        if ( (res > minq) || (res == minq && cur > minr) ) {
            panic("数值溢出，无法转换")
        }
        res = res*10+cur
    }
    if (!neg && res == math.MinInt) {   // 字符串为-math.MinInt，因为正整数比负整数少一个，因此转换会溢出
        panic("数值溢出，无法转换")
    }
    return neg?res:-res
}
```

