## 一、题目一

给定一个非负整数n，代表二叉树的节点个数。返回能返回多少种不同的二叉树结构。

```go
假设节点个数为N，根节点需要占用一个，因此可操作的节点实际只有N-1个。
1.如果 N = 0,那么能够返回0种不同的二叉树
2.如果 N = 1,那么能够返回1种二叉树
3.如果 N = 2,那么能够返回2种二叉树，自由节点在左侧或右侧时各一种
4.对于 N >= 3的情况，可以分为以下三种情况进行求解(以 N == 3 为例)：
1) 左子树0个节点，右子树2个节点
2) 左子树1个节点，右子树1个节点
3) 左子树2个节点，右子树0个节点
即左子树有i(i = 0……N-1)个节点,右子树有N-i-1个节点 分别进行递归求解

// 递归法
func treeNum(n int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    count := 0
    for left := 0;left <= n-1;left++ {
        leftcount := treeNum(left)
        rightcount := treeNum(n-1-left)
        count = leftcount * rightcount
    }
    return count
}

// 动态规划
func treeNum(n int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    dp := make([]int,n+1)
    dp[0] = 0
    dp[1] = 1
    
    for i:= 2;i<= n;i++ {   // i表示本轮的总结点个数
        for j:=0 ; j<= i-1 ; j++ {   // j表示本轮的左子树节点个数
            dp[i] += dp[j] * dp[i-j-1]
        } 
    }
    return dp[n]
}
```



## 二、题目二

一个完整的括号字符串的定义如下：

1.空字符串是完整的

2.每一个 左括号"(" 都有与之相匹配的 右括号")"

例如： （（）（））（）是完整的括号字符串     （）)（  和 （）（ 是不完整的括号字符串

现在有一个括号字符串s，请问现在需要在其中任意位置尽量少地添加括号，将其转化为一个完整的括号字符串。请问至少需要添加多少个括号？

```go
1.如何判断一个括号字符串是否是完整的？
定义一个整型变量count。当遇到左括号的时候count++，遇到右括号的时候count——。在遍历过程中，一旦发现count<0，则说明缺一个左括号"(",说明不完整 ; 当遍历完所有字符，若count ！=0 ，说明缺少右括号")",不完整。

2.借助上述的思想完成 需要添加多少个括号 的判断。
准备两个变量：count和sum，count的意义不变。在遍历字符串过程中，一旦发现count < 0,那么让sum++(sum用来统计缺少的左括号个数)，然后让count重新归零，继续向下遍历。遍历完成后，count的值就是缺少的右括号的个数。count+sum就是总共缺少的括号个数。
```



## 三、题目三

给定一个数组arr，求差值为k的数字对，要求不重复，即：如果k = 2，那么(2,4)和(4,2)只能算一个

```go
准备一个哈希表，先将arr数组中的重复元素去掉。
假设arr = [2 4 5 7 3 0 0 ], k == 2  哈希表的key值只会有{2 4 5 7 3 0}，多余的一个0被去掉了
接着遍历哈希表：
1.遍历到2的时候查看4是否存在
2.遍历到4的时候查看6是否存在
3.遍历到5的时候查看7是否存在
4.遍历到7的时候查看9是否存在
5.遍历到3的时候查看5是否存在
6.遍历到0的时候查看2是否存在
```



## 四、题目四

```go
1.如果arr1和arr2的平均值相等，假设都是100，此时是无法进行移动的，原因是：
	1）假设我们将arr1中小于100的数移动到arr2，那么arr1平均值上升，但是arr2平均值下降
	2) 假设我们将arr1中等于100的数移动到arr2，那么arr1和arr2的平均值都不会变
	3）假设我们将arr1中大于100的数移动到arr2，那么arr1平均值下降，但是arr2平均值上升
2.如果arr1平均值 < arr2 平均值，无法从arr1中移动一个数到arr2中实现magic操作，原因是：
	无论我们怎么取arr1中的数，都会导致arr2平均值下降
3.如果arr1平均值 > arr2 平均值， 符合下面条件的值可以从arr1中移动一个数到arr2中实现magic操作
假设arr1平均值为avg1，arr2平均值为avg2.
	1）从arr1取出的数字必须大于avg2，小于avg1
	2）从arr1取出的数组不能已经存在于arr2  （用一个哈希表hash记录）

对于符合上述两点的arr1中的数，我们每次取一个符合条件且最小的数移动到arr2。原因是这样可以最大程度拉大avg1和avg2的差距，增大arr1中可以实现magic操作的数据范围。	

在实现时，还需要注意：平均值可能是小数，因此需要用两个浮点型存储avg1和avg2；arr1、arr2、avg1和avg2、hash每一轮都要重新生成。且arr1需要进行排序
```

