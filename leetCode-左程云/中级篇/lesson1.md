## 一、题目一

给定一个有序数组arr，代表数轴上从左到右的n个有序点 arr[0] 、arr[1] 、 …… arr[n-1]。给定一个正数L，代表一根长度为L的绳子，求绳子最多能覆盖其中的几个点。

> 解法一

每次让绳子末端指向 arr 中的一个数，这样就可以直到绳子的左端落在数轴的哪一个点上。对于绳子左端指向的数字，可以在整个arr中求出在该数右侧大于其的距离最近的元素是谁。至此我们就可以获得绳子所覆盖的有序数组 左右两侧的 下标，从而知道覆盖的点数。

复杂度是 ： N次遍历 + N次求某数右侧最近的比他大的值(如果用二分法每次就是O(logN))

> 解法二

采用滑动窗口，滑动窗口的左侧遍历整个arr数组（左侧只会使arr中的元素）。当选定本轮滑动窗口的左侧位置时，就在arr中找到最大的不会让滑动窗口大小 大于 绳子长度的右侧位置，这样就确定了当arr[i]作为滑动窗口起点时包含的点数个数。

复杂度是：N次遍历确定窗口左侧位置 + 确定右侧位置( O(1)  )



## 二、题目二

小虎去商店买苹果，商店只提供6个每袋和8个每袋的包装。小虎现在只想购买恰好n个苹果，小虎想购买尽量少的袋数。如果不能购买恰好n个苹果，那么小虎将不会购买。输入一个整数n，表示想购买的苹果数，返回最少使用的袋子数。如果无论如何都不能正好装下，返回  -1。

> 方法一：

```go
1.如果苹果个数为奇数，那么直接返回-1，因为不可能用6和8凑出一个奇数
2.尽量用8个每袋的包装，8个每袋的包装越多意味着总共使用的袋子数最少（因为相同的苹果数，8包装袋子数量总是小于6包装袋子）
3.使用尽可能多的8包装袋子，如果剩余苹果数大于24(6和8的最小公倍数)，那么一定不是最优解，因为此时用6包装袋子总是差于用8包装袋子

func minBags(apple int) int {
    if apple < 0 || apple % 2 != 0 {
        return -1
    }
    bag6 := -1  // 记录6包装袋子使用个数
    bag8 := apple / 8   // 最多能够使用的8包装袋子数
    rest := apple - 8*bag8   // 剩余需要6包装袋子装的苹果数
    
// for循环从最多8包装袋子数开始,因为8包装袋子数越多，总袋子数越多。
// 一旦凑齐要求的apple个苹果就可以退出的原因也是基于此。
    for {  
        if bag8 < 0 || rest >= 24 {
            break
        }
        restUse6 := minBagBase6(rest)  // 剩余苹果需要的6包装袋子个数
        if restUse6 != -1 {
            bag6 = restUse6
            break
        }
        bag8--
        rest = apple - 8*(bag8)
    }
    if bag6 == -1 {   // 6包装袋子无法凑齐剩余苹果
        return -1
    } else {
        return bag6 + bag8
    }
}

func minBagBase6(rest int) int {
    if rest % 6 ==0 {
        return rest / 6
    } else {
        return -1
    }
}
```

> 方法二

```go
打表法，不考虑问题本身的数学原理，而是从结果中查找规律。

使用比较函数，苹果数从1~1000(甚至更大)，采用一种简单但暴力的算法找到凑齐当前苹果所需要的最少袋子数，规则如下：
1.当苹果数为奇数时，都返回-1，因为无法凑齐
2.当苹果数小于18时，没有特定的规律
3.当苹果数大于18时，展现出如下规律：每8个数为一组，奇数为-1，偶数为 (apple-18)/8+3


func minBag(apple int) {
    if apple %2 != 0 {
        return -1
    }
    if apple < 18 {
        switch apple {
            case 0:return 0
            case 6,8: return 1
            case 12,14,16: return 2
            defalut : return -1
        }
    }
    return (apple-18)/8+3
}
```



## 三、题目三

现在有n份青草和两只羊，两只羊分为先手和后手分别去吃这n份草。每只羊在吃的时候只能吃 4^m (0、4 、16 、64……)份草。规定每只羊都是绝顶聪明的，最后完成吃草动作的为获胜者。返回最后的获胜者

> 方法一

```go
func winner(n int) string {
    // 0  1  2  3   4
    // 后 先 后  先  先
    if n < 5 {
        if n==0||n==2 {
            return "后手"
        } else {
            return "先手"
        }
    }
    // 当 n >= 5 时
    base := 1   // base记录当前函数先手决定吃的份数
    for {
        if base > n  {   // 遍历了先手能吃的所有可能性
            break
        }
        // 这里注意：这里的子函数其实就是让后手羊称为先手,因此子函数若
        // 返回“后手赢”其实就意味着母函数(也就是当前函数)先手赢
        if winner(n-base) == "后手" {
            return "先手"
        } 
        if base > n/4 {  // 防止base*4 > math.MaxInt造成整数溢出
            break
        }
        base *=4
    }
    return "后手"   // 先手遍历了所有可能都不能赢
}
```

> 方法二

```go
打表法
试验了50次，草的份数从1~50,结果如下：
```

<img src="lesson1.assets/image-20230611170359965.png" alt="image-20230611170359965" style="zoom:50%;" />

```go
规律为：
每5个为一组，分别是“后先后先先”

func winner(n int) string {
    if n%5==0 || n%5 == 2 {
        return “后手”
    } else {
        return "先手"
    }
}
```



## 四、题目四

有一些排成一行的正方形。每个正方形已经被随机染成了绿色或者红色。

现在可以选择一个正方形然后用这两种颜色的任何一种进行染色，这个正方形的颜色将会被新的颜色覆盖。我们的最终目标是完成染色之后，每个红色R都比每个绿色G距离最左侧更近。

如：假设一开始的颜色为 s = RGRGR

我们重新染色之后变成RRRGG，重新涂染的正方形个数为2，而且没有比这个更好的染色方案了(最好是指需要重新染色的正方形个数最少)

> 方法一

```go
// 要染成题目要求的样式，其实就是让一行正方形分为两组，染色的目标就是让左半区域的正方形都是'R',右半区域的正方形都是'G'

func minPain(s []string) int {
    N := len(s)
    // 迭代，每次左侧部分的大小为i，右侧部分的大小为 N-i
    for i:=0;i<N;i++ {
        if L == 0 {   //只有右区域
         // 统计arr[0...N-1]一共有多少个R，将其全部染成G
        } else if L == N {   // 只有左区域
         // 统计arr[0...N-1]一共有多少个G,将其全部染成R
        } else {
         // 统计arr[0...L]一共有多少个G，全部染成R;统计arr[L+1...N-1]
         // 一共有多少个R，全部染成G
        }
    }
}
```

这种方式的时间复杂度是 O(N^2)

> 方式二

```go
上述的方案中我们需要反复使用原始数组arr来提取信息。也即以某一位i为分割点，统计arr[0...i]区域'G'的个数和arr[i+1...N-1]区域'R'的个数。
既然如此，我们可以对arr数组进行预处理，事先准备好两个数组：
1.数组一：长度和arr相同，每一位元素的含义是统计从0到该位时的'G'的个数
2.数组二：长度和arr相同，每一位元素的含义是统计从N-1到该位时的'R'的个数

再次对arr数组进行遍历，每次需要对左半区域统计染色个数时只需要根据数组一进行统计；每次需要对右半区域统计染色个数时只需要根据数组二进行统计
```



## 五、题目五

给定一个N*N的矩阵，只有0和1两种值，返回`边框`全部为1的最大正方形的边长长度。

例如：

```
01111
01001
01001
01111
01011
```

其中边框全部是1的最大正方形的大小为4*4，所以返回4

> 辅助知识

```go
对于一个N*N的正方形，其内部：
1.长方形的个数为 N^4,原因是在一个正方形中任取两个点分别作为长方形的左上角和右下角，可能的个数为N^2*N^2 = N^4
2.正方形的个数为 N^5,原因是在一个正方形中任取一个点作为左上角，可能的个数为N^2。再选取一个边长，可能性个数为N。因此正方形的个数就是N^2*N = N^3  (正方形的右下角不能随机选取)
```

> 方式一

```go
func maxBorder(m [][]int) int {
    N := len(m)  // 矩阵的长度
    M := len(m[0])  // 矩阵的宽度
    
    for row := 0;row < N;row++ {
        for col:=0;col<M;col++ {
            // 当前m[row][col]作为左上角
            // 枚举边长(边长的最大值取决于当前左上角横行跟纵向的最小值)
            for border := 1;border <= math.Min(N-row,M-col);border++ {
                // 验证这个正方形的四条边，看看是不是值都是1
                for {}
                for {}
                for {}
                for {}
            }
        }
    }
}
```

上述方法的时间复杂度为 O(N^4)

> 方式二

```go
这个题中可以进行改进的是：验证一个正方形的四条边，查看是否值都是1

可以实现准备两个矩阵：矩阵一的每一个点存储向右数连续1的个数；矩阵二的每一个点存储向下数连续1的个数

这样一来，在进行验证的时候：我们只需要对选中的左上角(row,col)进行验证，验证选中的边长border向右和向下是否是连续的1。验证通过的话再验证左下角向右是否是连续border个1，右上角向下是否是连续border个1。
这三个点全部验证通过，则可以确定是一个正方形边框。
```

该方法的时间复杂度为 O(N^3*1) = O(N^3)



## 六、题目六

给定一个函数f，可以在1~5中等概率返回一个数字。请加工出1~7的数字等概率返回一个的函数g

给定一个函数f，可以在a~b中等概率返回一个数字。请加工出c~d的数字等概率返回一个的函数g

```go
函数f可以在1、2、3、4、5中等概率返回一个，我们可以基于函数f设计出一个等概率返回0、1的函数function01

func function01(f) int {
    res := 0 
    for {   // 这个for循环等概率返回1~4中的一个数，如果获取到的是5则会重新进行生成
        if res != 5 {
            break
        }
        res = f()
    }
    if res <=2 {   // 如果是1、2则返回0
        return 0
    } else {    // 如果是3、4则返回1
        return 1
    }
}

题目要求我们获取一个等概率返回1~7的函数g，其实等价于等概率返回0~6，只要最后再+1即可
要等概率返回0~6，我们可以基于函数function01 用二进制拼凑的思想构造这个函数g
0~6至少需要3bit二进制数据才能表示，3bit可以表示0~7，但我们不要7，因此当摇到7的时候需要重新再摇一次
func g() int {
    res := 0
    for {
        if res != 7 {
            break
        }
        res = (function01() << 2) + (function01() << 1) + (function01() << 0)
    }
    return res + 1
}

再举一个例子，如果要等概率返回30~59范围内的一个数，等价于返回0~29范围的数
0~29至少需要5bit，5bit可以表示0~31，一旦遇到30、31则重新摇一个
func g() int {
    res := 0 
    for {
        res != 30 && res !=31 {
            break
        }
        res = (function01() << 4) + (function01() << 3) + (function01() << 2) +
        (function01() << 1) + (function01() << 0)
    }
    return res + 30
}
```

## 七、题目七

给定一个函数f ，以p概率返回0，以1-p 概率返回1。请加工出等概率返回0和1的函数g。

```go
重复使用f两次，分别作为0bit和1bit，如果结果是00或者11则重新摇。
如果是01则返回0，如果是10则返回1。01的概率和10的概率都是 p(1-p),等概率。
```

