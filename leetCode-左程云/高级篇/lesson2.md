## 一、题目一

现在有`n1+n2`种面值的硬币，其中前`n1`种为普通币，可以取任意枚，后`n2`种为纪念币，每种最多只能取一枚，每种硬币有一个面值，请问能有多少种方法拼出`m`的面值？

```go
总面值为m，可以分解为以下子问题：
1.面值为0用普通币拼出的方法数 * 面值为m用纪念币拼出的方法数
2.面值为1用普通币拼出的方法数 * 面值为m-1用纪念币拼出的方法数
3.面值为2用普通币拼出的方法数 * 面值为m-2用纪念币拼出的方法数
………………………………
m.面值为m用普通币拼出的方法数 * 面值为0用纪念币拼出的方法数

将这m个子问题的方法数累加起来就是最后的答案。

因此，这个问题就可以分解为两个动态规划问题：
1.用普通币拼出x面值的方法数
2.用纪念币拼出y面值的方法数
```

```go
第一个动态规划:
假设面值是从0~10，硬币面值有: 3 1 2 4
列表示: 剩余需要凑的面值
行表示: 硬币面值

初始条件：
1.第一列必定为全1，表示凑齐0面值只有一种方式，就是不需要任何硬币
2.最后一列可知，其物理意义为：剩余钱数下需要用面值为4的硬币凑出(因为数组遍历到面值为4,再不凑齐就是真凑不齐了)。此时只有4以及4的倍数可以用面值为4的硬币凑出。

依赖条件: （当前硬币使用0个，1个，2个，……,k个）
dp[i][j] = dp[i+1][j-0] + dp[i+1][j-coins[i]] + dp[i+1][j-2*coins[i]]+……+dp[i+1][j-k*coins[i]]   需要保证j-k*coins[i] >=0

目标值:第一行分别代表在不同面值下拼出的方法数。
```

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0(3) | 1    |      |      |      |      |      |      |      |      |      |      |
| 1(1) | 1    |      |      |      |      |      |      |      |      |      |      |
| 2(2) | 1    |      |      |      |      |      |      |      |      |      |      |
| 3(4) | 1    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 0    |



## 二、题目二

给定两个一维int数组`A`和`B`

其中：A是长度为m的从小到大排好序的有序数组；B是长度为n的从小到大排好序的有序数组。希望从A和B数组中，找出最大的K个数字，要求：使用尽量少的比较次数。

```go
方法一：双指针
准备一个大小为m+n的数组set。两个指针分别从A和B的头开始遍历，假设数组A指针指向数小于数组B指针指向数，那么将A指向数加入set，A指针++，重复此操作直到填满set。最后得到的set数组就是一个有序的数组。
set的后K个数就是求解的目标。

时间复杂度是O(m+n)，如果 M+N很大，但K很小，这种方案就很低效。

方法二：
假设A和B合并后的有序数组为set(没有真的将set挨个求出)。假设我们需要求set数组的第i位是多少：
1.假设这一位在原A数组中，那么我们先找到A数组的中位数mid，假设在A中该数前面有k个数。
2.我们用二分法在B数组中寻找小于mid的有多少个数，此时根据个数l的多少就会有三种情况：
	1.l == (i-1)-k,那么就意味着在set中mid前面有i-1个数，因此mid就是set数组的第i位
	2.l> (i-1)-k,那么就意味着在set中mid前面有 > i-1个数，mid不可能是set第i位，此时说明中位数在mid之前，继续使用二分法扎到		在A数组中mid左区域的中位数mid_1。采用同样的方法求在set中mid_1前面有多少个数，如果==i-1个，那么mid_1就是set的第i个	    数，否则继续二分。如果A数组访问越界也找不到某数前面有i-1个数，说明第i个数不在数组A而是在数组B
	3.l< (i-1)-k,那么就意味着在set中mid前面有 < i-1个数，mid不可能是set第i位，此时说明中位数在mid之后，采用相同的方法二分		法跳到mid右区域进行查找…………
3.如果数不在A数组，那么就到B数组中找，方法相同。

这样的方法，找一个数的时间复杂度是 O(logN * logM) , 因此找K个数的时间就是 K*O(logN * logM)


方法三：
先假设 m == n

1.m==n 为偶数
找两个数组的下中位数。如果这两个数相等，那么set的下中位数就是这个数；如果不相等，假设 A的> B的，那么下中位数只会出现在A的左侧和B的右侧，而整两个区域又是长度相等且是偶数，因此可以递归。最后子问题递归获得的下中位数就是母问题的下中位数


2.m==n 为奇数
此时中位数只有一位。如果中位数相等，那么set的中位数就是这个数；如果不相等，假设 A的> B的，那么中位数只会出现在A的左侧和B的下右侧(所谓下右侧就是正下方+右侧)，也就是说B的中位数可能成为set的中位数。因为两个区域长度不相等，因此无法直接递归。采用的方法是：
预处理，人为判断B中位数能否成为set中位数，方法是检查B中位数是否大于等于A左侧最右侧数：如果是，那么B中位数就是set中位数；否则就不是。如果不是的话，可能区域就变成：A的左侧和B的右侧，这两个区域大小相等，根据长度奇偶，采用不同的函数进行递归。
```
现在来推 m!=n 的情况：
假设 m == 10   n == 17，A和B合并后的有序数组为set，对于set[i]
1.  1 <=i <= 10, 此时set[i]必然出现在A[1……10]和B[1……10]中，这是两个等长的区域，用上述方法求即可
2.  18 <= i <= 27

​	   	假设 i == 20

​	A  ~~1  2~~  <u>3  4  5  6  7  8  9  10</u>

​	B  ~~1  2  3  4  5  6  7  8  9~~  <u>10  11  12  13  14  15  16  17</u>

​	如上，可以确定的是：A数组的1/2两位不可能成为set的第20个数(1最多是18位，2最多是19位)；B数组的1……9这九位同理也不可能。

​	这里会有一个规律：A数组剩下可能的数个数  == B数组剩下可能得数个数。此时已知的前11位就是A、B数组中被淘汰的数。

​	此时如果我们在A(8) + B(8)中求第8位，那么他是set的第11+8 == 19位，不到20位。因此，我们需要额外判断A[3]和B[10]能否成为set	的第20位（A[3 ]> B[17 ] 或者  B[10)]> A[10] ），如果都不是此时set的前13位就会被确定，我们只需从剩下的A(7)和B(7)中找到第7位	即可。

	3. 11<=i <=17，

​		假设i == 15

​	A  <u>1  2  3  4  5  6  7  8  9  10</u>

​	B  ~~1  2  3  4~~  <u>5  6  7  8  9  10  11  12  13  14  15</u>  ~~16  17~~

​	如上，可以确定的是：A数组的每一位都是有可能成为set的第15位的。B数组的1~4位不可能，因此4最好也就是set的第14位；B数组	的16~17也不可能，因为16最小也是set的第16位。

​	这里也会有一个规律：B数组剩余数  == A数组剩余数 + 1。因此我们需要人为判断 B[5]是否是set的第15位（B[5]  >  A[10]）。

​	如果不满足，此时set的前5位已知，我们需要从A(10)和B(10)中找出第10位即可。



时间复杂度：因为要求递归求的时候两个数组长度要一致，因此必定<=小数组长度。因此复杂度是 k*log( min(m,n) )
