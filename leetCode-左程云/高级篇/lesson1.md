## 一、题目一

给定一个数组，求如果排序之后，相邻两数的最大差值。要求时间复杂度O(N)，且要求不能用基于比较的排序。

```go
1.如果数组内数字的范围是 1~N共 N个数，那么我们需要准备 N+1 个桶（为什么是N+1后面会解释）
2. 将数字均分为 N+1 份，每个桶代表一段范围，将数字放到对应的桶中。假设数组最大值为max，最小值为min，长度为len，对于任意一个数num，其对应的桶编号是: len * (num-min)/(max-min)

3.因为数组最多有N个数，最小值需要放到第一个桶，最大值需要放到最后一个桶，那么中间必然会有一个空桶

4.必然有 桶内数字的差值 <= 两个相邻非空桶的数字差值。相邻两数的最大差值只会出现在相邻的桶与桶之间，而非桶内。多出一个桶的目的就是设计一种平凡解：即相邻两数之间的差值要想最大，必然要大于等于空桶两侧非空桶差值。

5.因为最大差值只会出现在桶与桶之间，而且是上一个桶的最大值和下一个桶的最小值(这两个值在排序后是相邻的)，因此每一个桶只需要保存最大值和最小值即可。

```

## 二、题目二

给出n个数字 a1，a2，……，an，请问最多有多少个不重叠的非空区域，使得区间内数字的xor == 0 的数量最多。

```go
1.异或运算： 1^0 = 1  1^1 = 0  0^0 = 0  100^0 = 100 100^1 = 101 100^100 = 0

2.准备一个数组dp，长度 == n。dp[i]记录0~i范围内异或值==0的区域最大个数。

3.求dp[i]:  
第一步：对于每一个i，求距离自己最近的k。
假设一个区域0~i，该区域的异或和 == 1000，求k的方法是: 在0~i区域内找到一个p，使得0~p区域异或和 == 1000，且p是所有符合区域和 == 1000的距离i最近的一个右边界，此时k == p+1。 因此可以准备一个map，map[xor] = recent_xor (xor是出现过的区域异或和，recent_xor表示最近出现的区域右边界)

第二步：如果求到了k，那么dp[i] = dp[k-1] + 1，同时更新map ; 如果没求到，那么dp[i] = dp[i-1]，同时新增map

```

```go
func mostEOR(arr []int) int {
    xor := 0
    dp := make([]int,len(arr))
    
    xorMap := make(map[int]int)
    xorMap[0] = -1
    
    for i:=0;i<len(arr);i++ {
        xor ^= arr[i]   // 0……i所有数的异或和
        if pre,ok:=xorMap[xor];ok {  // 上一次，这个异或和出现过
            if pre == -1 {
                dp[i] = 1  // 专门为dp[0]设置的
            } else {   // pre+1^……i是一个最优的划分区域，且是最后一个区域
                dp[i] = dp[pre] + 1
            }
        }
        // dp[i] = math.Max(dp[i-1],dp[k-1]+1)
        if i > 0 {
            dp[i] = math.Max(dp[i-1],dp[i])
        }
        xorMap[xor] = i
    }
    
    return dp[len(dp)-1]
}
```



