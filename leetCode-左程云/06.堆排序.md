### 一、堆是什么

堆就是一颗完全二叉树

### 二、堆排序的数据结构

堆排序使用的是一种名为**大根堆**的数据结构，所谓大根堆就是指在当前完全二叉树数，任意子树(包括树本身)都满足：根节点存储的数值要大于其左右孩子存储的数值。

由于大根堆本身使用数组进行存储的，所以节点之间的下标关系如下：

- 一个子树的根节点下标为i，那么它的左右子树下标分别为 2*i+1 和 2 *i+2
- 如果一个节点的下标为i，那么他的父节点的下标为 i-1/2



### 三、堆插入（`heapInsert`）

堆插入用于将一个随机的数组构建为一个**大根堆**：

首先有一个指针`heapSize`，用来指示当前大根堆下一个元素在数组（大根堆用数组来进行存储）的存储下标。

1. 算法运行第一步，因为此时大根堆数组arr的`heapSize` == 0，那么将从源数组src取出第一个元素，放到arr[0]上，然后heapSize++
2. 算法第二步，再次从src取出一个元素，放到arr[1]上(其实是arr[heapSize])。然后比较arr[heapSize]与其父节点arr[（heapSize-1）/2]的大小，如果当前arr[heapSize] > arr[(heapSize-1)/2]，那么将当前节点与其父节点进行交换，否则继续插入下个元素。完成本次交换之后，再将交换后的当前节点继续与上层的父节点(原本的爷爷节点)进行比较、交换，直到父节点是根节点或者当前节点小于根节点为止
3. 持续进行第二步，直到源数组src的所有值插入到大根堆数组arr



堆插入操作的时间复杂度为 O(logN),因为当前节点只需要不断与父节点进行比较、交换，因此复杂度应该是二叉树的层数logN



### 四、取出一个最大值并进行堆化(`heapify`)

从完成所有插入操作的大根堆上取出最大的一个数，然后使用堆化保持大根堆的结构

从大根堆上取最大的元素其实就是将根节点上的数取出，问题在于如何在取出根节点之后仍然保持大根堆的结构，做法是这样的：

1. 保存根节点的数值，作为本次的返回值
2. 将最后插入的叶子节点的数值拷贝到根节点上，然后heapSize--（heapSize--其实就相当于将这个最后的叶子节点从当前数组中剔除，尽管在内存上依然存在的这个数字，但是对于用户来说已经无法访问了）
3. 将根节点的两个孩子节点进行大小的比较，比较大的那一个再跟新的根节点进行比较，如果`新根节点 < 较大的孩子节点`，将新根节点与较大的孩子节点进行交换。完成本次交换之后，这个新根节点此时成为了子树的新根节点，继续步骤3操作：如果新根节点还是小于孩子节点，那么再次进行交换。直到当前节点左孩子的下标大于heapSize（意味着越界）。

步骤三的这种做法叫做heapify，堆化。作用是将结构被破坏的大根堆重新组装为一个新的大根堆。



`heapify`操作的时间复杂度为 O(logN)，节点只需要不断和孩子节点进行比较、交换，因此复杂度也是二叉树的深度logN



### 五、堆结构恢复

一个大根堆，如果用户修改了其中一个节点的值，如何再次将其恢复为一个大根堆？做法如下：

1. 如果节点的值变大了，那么需要将该节点上移，需要采用堆插入时的做法，不断将节点与父节点进行比较、交换
2. 如果节点的值变小了，那么需要将该节点下移，需要采用堆化时的做法，不断将节点与孩子节点比较、交换



### 六、堆排序算法

任意给定一个数组arr，要求对其完成从小到大的排序，使用堆排序算法流程如下：

1. 使用堆插入算法形成一个大根堆
2. 将大根堆的根节点和最后一个叶子节点arr[heapSize]进行交换，然后heapSize-- （将arr的最大值放到数组的最后）。接着使用heapify重新构建大根堆
3. 重复步骤二，直到heapSize == 0
4. 完成排序。

```go
func heapSort(arr []int){
    if arr == nil || len(arr)<=1{
        return
    }
     //构建大根堆 
    for i:=0;i<len(arr);i++{  // O(N)
        heapInsert(arr,i)	//O(logN)
    }
    heapSize := len(arr)
    // 将根节点与最后一个叶子节点交换
    swap(arr,0,heapSize)  
    heapSize--
    for {    // o(N)
        if heapSize == 0{
            break
        }
        // 重新堆化
        heapify(arr,0,heapSize)  //o(logN)
        // 再次将根节点与最后一个叶子节点交换
        swap(arr,0,heapSize) 
        heapSize--
    }
}
```

上面的算法流程可以得知：

1. 堆排序算法的时间复杂度为 O(N*logN)
2. 空间复杂度为O(1)



上述算法可以优化的点是：构建大根堆的过程。

```go
for i:=0;i<len(arr);i++{  // O(N)
    heapInsert(arr,i)	//O(logN)
}
```

构建大根堆的算法是一个O(N*logN)的时间复杂度，但如果改成下面这种方式，就可以变为O(N)

```go
for i:=len(arr)-1;i>=0;i--{
    heapify(arr,i,len(arr))
}
```

从最底层节点开始heapify，逐步将一颗二叉树变为大根堆



### 七、堆排序扩展问题

已知一个几乎有序的数组，几乎有序是指：如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序

> 这个问题可以用小根堆来解决

```go
func sortArrDistanceLessK(arr []int,k int){
    var heap = new(heap) // 构建一个小根堆对象(自行实现)
    index := 0
    for ;index<Math.min(len(arr),k);index++{
        heap.add(arr[index])  // 将前k个数添加到heap中(构建一个长度为k的小根堆)
    }
    i := 0
    // 继续把后续 k+1 ~ len(arr)-1的数加入到小根堆中
    for i=0;index< len(arr); i++,index++{
        heap.add(arr[index])  // 添加一个数到小根堆
        arr[i] = heap.poll()  // 弹出一个最小值
    }
    // 最后将 k 个数挨个弹出(每次弹出最小值)
    for {
        if heap.IsEmpty() {
            break
        }
        arr[i++] = heap.poll()
    }
}
```

问：为什么第一步要将0 ~ k的元素添加到小根堆中？

答：因为题目要求每个元素移动的距离可以不超过k。而第0个数距离0的距离为0，第K个数距离第0个元素的距离为K。对于第K+1个元素，他永远不可能比前K个元素都小，否则他需要移动K+1步
