### 一、归并排序

归并排序是一种利用递归完成的排序方法，其：

1. 计算时间复杂度为：O(N*logN)
2. 空间复杂度为：O(N)



基本的思路是：将整个需要排序的数组一分为二，然后在每一部分上进行排序，当两部分都完成排序之后，每次从两部分中取出一个小数保存到一个新数组中......完成排序后，再将新数组的值拷贝到原数组。

代码如下：

```go
// 归并排序
func process(arr []int, L, R int) {
	if L == R { // 当前分区只有一个数,不需要进行排序
		return
	}
	M := L + ((R - L) >> 1)
	process(arr, L, M)   // 对左分区进行排序
	process(arr, M+1, R) // 对右分区进行排序
	merge(arr, L, M, R)  // 对完成排序的左右分区再进行排序
	return
}

func merge(arr []int, L, M, R int) {

	temp := make([]int, 0) // 临时存储
	left := L              // 左分区扫描指针
	right := M + 1         // 右分区扫描指针

	// 第一个循环，直到将左右分区中的一个读完
	for {
		if left > M || right > R {
			break
		} else {
			if arr[left] < arr[right] {
				temp = append(temp, arr[left])
				left++
			} else {
				temp = append(temp, arr[right])
				right++
			}
		}
	}

	// 第二个循环,负责读完剩下的分区
	for {
		if left > M {
			break
		}
		temp = append(temp, arr[left]) // 无需再进行其他判断,直接进行拷贝即可
		left++                         // 指针递增
	}

	for {
		if right > R {
			break
		}
		temp = append(temp, arr[right])
		right++ // 指针递增
	}

	// 第三个循环,将完成排序的本区域全部拷贝到原数组对应区域
	for i, v := range temp {
		arr[L+i] = v
	}

	return
}

func main() {

	arr := []int{2, 4, 1, 5, 3, 7, 8, 0}
	fmt.Printf("Befor mergeSort: %v\n", arr)
	process(arr, 0, len(arr)-1)
	fmt.Printf("After mergeSort: %v\n", arr)
}
```



归并排序时间复杂度计算(可以使用master公式):

a = b = 2

由于每次除了分区递归之外，在merge()函数中还需要分别扫描左右分区（也即要扫描整个原数组），然后还需要扫描辅助排序数组temp，所以这些额外的时间复杂度为 O(N) ---->  d = 1

log(2,2) == 1 == d  , 所以总的**时间复杂度为 O(N * logN)**



**空间复杂度就是O(N)** ---> 额外的temp数组大小



### 二、求小数之和

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

如: [1,3,4,2,5]。1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1、3、4、2；所以小和为1+1+3+1+1+3+4+2 = 16



该问题的另一种求解思路时：当前数，其右边出现的所有比自己大的数，自己都将成为它们的小数之一。比如[1,3,4,2,5]中，1右边的所有数都比1大，因此1将成为他们所有数字的小数之一。



程序的实现可以通过修改归并排序实现：

```go
func process(arr []int, L, R int) int {
	if L == R {
		return 0
	}
	M := L + ((R - L) >> 1)
	leftSum := process(arr, L, M)    // 左区域进行排序时产生的小和之和
	rightSum := process(arr, M+1, R) // 右区域进行排序时产生的小和之和
	mergeSum := merge(arr, L, M, R)  // 左右合并时产生的小和之和

	return leftSum + rightSum + mergeSum // 与原始归并排序不一样的地方，需要返回小和
}

func merge(arr []int, L, M, R int) int {
	temp := make([]int, 0)
	left := L
	right := M + 1
	smallSum := 0

	for {
		if left > M || right > R {
			break
		} else {
			if arr[left] < arr[right] {
				temp = append(temp, arr[left])
				smallSum += arr[left] * (R - right + 1) // 当前数将成为右边所有大数的小数(与原始归并排序不一样的地方)
				left++
			} else {
				temp = append(temp, arr[right])
				right++
			}
		}
	}

	for {
		if left > M {
			break
		} else {
			temp = append(temp, arr[left])
			left++
		}
	}

	for {
		if right > R {
			break
		} else {
			temp = append(temp, arr[right])
			right++
		}
	}

	for i, v := range temp {
		arr[L+i] = v
	}

	return smallSum
}
```

### 三、逆序对问题

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。