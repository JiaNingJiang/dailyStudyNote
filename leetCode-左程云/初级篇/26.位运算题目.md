## 一、题目一

给定两个有符号32位整数a和b，返回a和b中较大的。

要求：不能进行任何比较判断。

```go
// 该函数的参数，只能是1和0
// 如果输入1，返回0；如果输入0，则返回1
func flip(n int) int {
    return n ^ 1
}

// 此函数，如果输入非负数则返回1；如果输入负数则返回0
func sign(n int) int {
    return flip(  (n>>31) & 1)
}

// 没有考虑a-b溢出的可能性
func getMax1(a,b int) int {
    c := a-b
    scA := sign(c)  // a-b为非负数,scA = 1; a-b为负数，scA=0  （a的状态栏）
    scB := flip(scA)  // scB与scA总是相反的状态  （b的状态量）
    
    return a * scA + b * scB   // 只可能返回a 、 b中的任何一个（因为另一个的状态量必然是0）
}

// 考虑了a-b溢出的可能性（a与b异号时返回为正数的; a与b同号时根据c的符号进行返回,c为正则返回a,c为负责返回b）
func getMax2(a,b int) int {
    c := a-b
    sa := sign(a)  // a的符号位(非负=1，负数=0)
    sb := sign(b)  // b的符号位
    sc := sign(c)  // c的符号位
    difSab := sa^sb   // a、b符号相异时为1
    sameSab := flip(difSab)  // a、b符号相同时为1
    returnA := difSab * sa + sameSab * sc   // a、b符号相异时可能溢出，因此 returnA = sa，最终是否返回a取决于sa是否为1(a位非负)；a、b符号相同不可能溢出。因此returnA = sc，最终是否返回a取决于sc是否为1(a-b非负)
    returnB := flip(returnA)  // 与returnA互斥
    
    return a * returnA + b * returnB
}
```

## 二、题目二

给定一个32位正数，判断是否是2的幂、4的幂

### 2.1 判断是否是2的幂

> 思路一：
>
> 一个数字如果是2的幂，那么他必定有且只有一位上是1，其余位都是0。（除了该数为0的情况，需要注意1 == 2^0）

```go
rightOne := target & (~target + 1)  // 提取出最右侧的1

if rightOne == target {
    return true
} else {
    return false
}
```

> 思路二：
>
> 一个数如果是2的幂，那么该数减去1之后，再与原数相与，结果必定为0

```go
if (target & (target - 1) == 0) {
    return true
} else {
    return false
}
```

### 2.2 判断是否是4的幂

如果一个数字是4的幂次，那么他一定首先是2的幂次。除此之外我们观察4的幂次的特征：

……0000001   4^0

……0000100   4^1

……0010000    4^2

……1000000    4^3

可以看出，规则是：分别在0 、 2 、4 、6 、8、…… 位上是1,其余各位都是0（**跟2的幂次一样，只在一位上是1**）

因此只需要在将数与 ……0101 0101 0101  ( 0x …… 555) 相与，结果为1则是4的幂次。

```go
if (target & (target - 1) == 0 && (n & 0x55555555)!=0) {   // 32位数，因此是0x55555555 
    return true
} else {
    return false
}
```

## 三、题目三

不使用算术运算符，完成两个有符号32位整数a和b的 加、减、乘、除运算。不需要考虑两数运算后溢出的情况。

### 3.1 加法运算

两数相加，等效于不断使用两个数的 异或值、相与后左移一位 这两项的持续运算结果，直到 相与值为0。

比如：15（01111）+ 11（01011）

​		01111

​		01011

----------------

^  	00100            // 无进位相加结果

&<1 10110			// 进位信息

---------------------------------------------------

^	  10010

&<1 01000

------------------------------------------

^	  11010

&<1 00000

因此结果就是 26（11010）

```go
func Add(a, b int32) int32 {
	noCarryAdd := a
	carryInfo := b
	for {
		if carryInfo == 0 {
			break
		}
		noCarryAddTemp := noCarryAdd ^ carryInfo
		carryInfoTemp := (noCarryAdd & carryInfo) << 1

		noCarryAdd = noCarryAddTemp
		carryInfo = carryInfoTemp
	}
	return noCarryAdd
}
```

### 3.2 减法运算

a - b = a + (-b)    

```go
// 取一个数的相反数：对数字求反后+1
func negNum(n int) {
    return add(~n,1)  
}

func minus(a,b int) int {
    return add(a,negNum(b))
}
```

### 3.3 乘法运算

假设 26(011010) * 22(010110)

​						011010		a

​					*  010110		b

-----------------------------------------------

​						000000    0*011010(a)<<0

​					  011010      1*011010(a)<<1

​	                011010		1*011010(a)<<2

​				  000000		  0*011010(a)<<3

​				011010			1*011010(a)<<4 

-------------------------------------------------------------------

​				1000111100   = 572

```go
func multi(a,b int) int {
    res :=0
    for {
        if b == 0 {
            break
        }
        if ((b & 1) != 0){
            res = add(res,a)
        }
        a = a << 1
        b = b >> 1   // 需要是无符号左移
    }
    return res
}
```

### 3.4 除法运算

除法是乘法的逆运算。以上题为例 26(011010) * 22(010110) = 

572(1000111100 )。

1000111100  实际等于 011010<<4 + 011010<<2 + 011010<<1

因此如果求 572(1000111100 ) / 26(011010) ,遵循以下步骤：

1. 将011010左移到极限（必须小于1000111100）
2. 如果572大于26左移之后的结果，则相减，并将商对应位置为1
3. 再将011010左移到极限（必须小于相减之后结果）
4. 如果第一次相减之后的结果 > 26左移后的结果，则相减，并将商对应位置为1
5. 重复……，直到原被除数减为0（整除）或者再也没有能力减去26左移的结果（剩余数为余数）

```go
func div(a,b int) int {
    x := isNeg(a) ? negNum(a):a
    y := isNeg(b) ? negNum(b):b
    res := 0
    // 核心是下面这个for循环
    for i:=31;i>-1;i=minus(i,1) {
        if (x>>i) >= y {  // 被除数右移 > 除数 
            res |= (1<<i) // 商对应位置为1
            x = minus(x,y<<i)  // 更新被除数
        }
    }
    return isNeg(a) ^ isNeg(b) ? negNum(res):res
}
```

注：为什么采用被除数右移，而非除数左移？

答：因为除数左移可能会导致除数溢出（符号位被影响，比如因为左移导致符号位从0变成了1，使得除数变成了负数）
