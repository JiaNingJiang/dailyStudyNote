### 一、滑动窗口结构的定义

- 滑动窗口有左边界L和有边界R
- 在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分
- L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口
- L和R都只能往右滑

### 二、滑动内最大值和最小值的更新结构

如果题目的要求是每次获取窗口内的最大值，那么窗口本身就必须是递减结构(窗口内元素由大到小)；如果要求每次获取的是最小值，那么窗口本身就必须是递增结构(窗口内元素由小到大)。所谓的递增和递减结构是指，滑动窗口内不论是移除一个值还是进入一个值，窗口内的元素都必须一直保持这种元素之间的大小关系。

为了实现滑动窗口的这种更新结构，我们需要使用一种新的数据结构：单调双端队列

### 三、单调双端队列

所谓的单调是指：队列中存储的所有元素，其大小必须是单调的

双端是指：作为一种特殊的队列，队首是除了可以出元素还可以入元素；队尾除了入元素还可以出元素。

为了保持时刻的单调性，元素进入队列是需要遵循特定的规则：

假设我们要实现一种递减性（滑动窗口的最大值更新结构）。假设原数组arr = [3 2 4 6 3 5 5 3 5]

#### 3.1 新元素的插入

如果要将一个新元素的记录插入到队列中，遵循的规则如下：

- 元素总是从队尾进入，因此此时的队列记录元素3，且**记录的是元素在原数组中的下标**，即 queue = [ 0 ]
- arr[1] = 2 < 3 ，因此元素2的下标也从队尾进入。queue = [ 0 1 ]
- arr[2] = 4 > 2 ，因为元素4比当前队列尾部的元素2要大，为了保持单调递减，因此将元素2的记录从queue中删除（**即将元素2的记录从队列中弹出，且永不再加入**）；因为arr[2] = 4 > 3 ，继续将元素3的记录从队列弹出，此时 queue = [2] 

总结：为了保证单调递减性质，每次插入都从队尾插入，一旦遇到比待插入值小（或者相等）的记录，直接将此记录从队尾弹出且后续再不入队。需要注意：**插入到双端队列中的都是原始元素的在原数组中的下标值。**

#### 3.2 旧元素的删除

所谓旧元素的删除，就是将排在queue前面的记录进行弹出。队列元素的弹出在滑动窗口中意味着旧元素的过期。

假设我们的滑动窗口内现已记录的元素是 [3 2 4 6 ]，此时对应的双端队列为 queue = [3]。现在我们要将滑动窗口的左边界依次往后移（即弹出对相应元素的记录）：

1. 检查元素3的下标0是否还在queue中，因为不在，所以对queue没有操作
2. 检查元素2的下标1是否还在queue中，因为不在，所以对queue没有操作
3. 检查元素4的下标2是否还在queue中，因为不在，所以对queue没有操作
4. 检查元素6的下标3是否还在queue中，我们发现在，此时将元素6的记录（下标3）从队首进行弹出。

总结：为了保证单调递减性质，每次删除都从队头移除，如果要移除的元素记录本身已经不在双端队列中则不需要任何额外操作；如果要移除的元素记录本身在队列头部则将其从队首出队。

#### 3.3 单调双端队列的原理

以递减队列为例：

队列中总是保存具有最大可能成为最大值的元素的记录。

1. 新元素进队列时，都是从队尾进。
   1. 一旦发现新插入的元素比之前的元素要大，那么之前的元素的记录都要从队列中弹出。这是因为新插入的这个元素在当前的滑动窗口中肯定是最大的，因此无需保留之前元素的记录；
   2. 而如果新插入元素比之前的元素要小，则直接将其记录追加到队列中。这是因为这个新插入的元素在前方元素过期时，有可能成为滑动窗口内的最大值，因此要保留对它的记录。
2. 旧元素出队列时，都是从队首出：因为进队列时的特殊规则，导致当前要出队列的元素，其记录本身可能已经不存在于双端队列中，因此不是每次都会从queue中弹出一个元素

#### 3.4 时间复杂度分析

因为每个元素的只会进队列一次，出队列一次，假设原数组大小为N，那么当滑动窗口扫完整个原数组，那么时间复杂度就是O(N)。平均下来，对于每一个元素，平均的时间复杂度就是 O(N)/N = O(1)

### 四、题目

有一个整形数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑动一个位置。

例如，数组为[4 3 5 4 3 3 6 7]，窗口大小为3时：

[4 3 5] 4 3 3 6 7		窗口最大值为5

4 [3 5 4] 3 3 6 7		窗口最大值为5

4 3 [5 4 3] 3 6 7		窗口最大值为5

4 3 5 [4 3 3] 6 7		窗口最大值为4

4 3 5 4 [3 3 6] 7		窗口最大值为6

4 3 5 4 3 [3 6 7]		窗口最大值为7

如果数组长度为n，窗口大小为w，则一共会产生 n-w+1个窗口的最大值。

请实现一个函数。输入：整型数组arr，窗口大小为w。输出：一个长度为n-w+1的数组res，res[i] 表示每一种窗口状态下的最大值。（本例中返回结果应该是[5 5 5 4 6 7]）