## 一、单调栈的定义

这种数据结构在栈的基础上，栈内的元素是单调有序的，所以单调栈分为单调递增栈和单调递减栈（增减性的划分是根据**栈顶到栈底的元素变化规律**）

- 单调递增栈： 从栈顶往栈底看，是单调递增的关系（含相等）
- 单调递减栈： 从栈顶往栈底看，是单调递减的关系（含相等）



## 二、问题

利用单调栈解决如下问题：

对于任意的一个数组，针对任何一个元素，都能返回该元素左侧和右侧的比他大(或者小)的且距离最近的值。要求这个过程的时间复杂度尽可能的小。

最简单的解决方案就是：对于任意一个元素arr[i]，分别在其左侧和右侧遍历到底，最终获取结构，但这样做的时间复杂度为O(N^2)。

为了降低时间复杂度，可以利用单调栈进行改进。

## 三、无重复值情况

假设现在有一组数：5 4 3 6 1 2 0。如果从左往右依次进**单调递增栈**，那么是这样操作的：

1. 元素5的下标0入栈（依旧是**元素下标进栈**）
2. 元素4 < 5，因此下标1进栈
3. 元素3 < 4 ，因此下标2进栈
4. 元素6 > 3，此时如果进栈将破坏栈的单调结构，因此需要将元素3的下标2出栈。要注意：元素下标一旦出栈，就不会再次进栈，因此需要返回该元素距离最近的比他大的左右元素。
   1. 元素出栈时：其右侧距离最近的比他大的值就是待入栈的元素，这里就是元素6
   2. 元素出栈时：其左侧距离最近的比他大的值就是其在栈中的下一个元素，这里就是元素4
5. 元素3出栈成功，元素6再次尝试进栈。但是元素6 > 4。重复步骤4
6. 元素4出栈成功，元素6再次尝试进栈。但是元素6 > 5。重复步骤4
7. 元素5出栈成功，元素6再次尝试进栈。进栈成功。
8. 采取相同的步骤处理其他元素。直到数组中没有元素可以进栈，此时将栈中的元素挨个弹出，对于这些元素：
   1. 其右侧距离最近的比他大的值不存在，因此是无
   2. 其左侧距离最近的比他大的值就是其在栈中的下一个元素

## 四、有重复值情况

假设现在有一组数：5 4 3 4 5 3 5 6。如果从左往右依次进**单调递增栈**，那么是这样操作的：

1. 元素5的下标0**作为一个链表头结点**入栈（**每次进栈的都是链表节点**）[[0]]
2. 元素4的下标1入栈  [[0],[1]]
3. 元素3的下标2入栈   [[0],[1],[2]]
4. 元素4 > 3，不能继续入栈。此时元素3的下标2出栈，元素3的左max是4，右max也是4  [[0],[1]]
5. 元素4 = 4，作为后续的链表节点加到下标1节点之后 {1,3} --> 4   [[0],[1,3]]
6. 元素5 > 4，不能继续入栈。此时按照**从链表尾部到头部**的顺序相继弹出：元素4(下标3)的左max是5，右max是5；元素4(下标1)的左max是5，右max是5   [[0]]
7. 元素5 =5 ，作为后续的链表节点加到下标0节点之后 {0,4} --> 5   [[0,4]]
8. 元素3的下标5进栈   [[0,4],[5]]
9. 元素5>3，不能继续入栈。此时元素3的下标2出栈，元素3的左max是4，右max也是4.  [[0,4]]
10. 元素5 = 5 ，作为后续的链表节点加到下标4节点之后 {0,4,6} --> 5   [[0,4,6]]
11. 元素6 > 5，不能继续入栈。此时按照从链表尾部到头部的顺序相继弹出：元素5(下标6)的左max没有，右max是6；元素5(下标4)的左max没有，右max是6；元素5(下标0)的左max没有，右max是6       [[7]]
12. 没有剩余元素可取，元素6出栈，左max和右max都没有

## 五、应用

假设有这样一种定义：数组各元素的累加和与数组最小值的乘积，称为该数组的指标A。

我们给定任意一个数组，请返回该数组的所有子数组中，指标A最大的值。

假设数组为：[5 3 2 1 6 7 8 4]

> 思路：可以从头开始遍历整个数组，假设当前正在遍历的元素是 arr[i] ，寻找以arr[i]为最小值的子数组中累加和最大的一个。当遍历完整个数组之后，我们可以得到以各元素为最小值的具有最大指标A的子数组，将这些子数组进行比较，最终返回最大的指标A。

上面的解题思路可以通过单调栈来实现：对于当前正在遍历的元素arr[i]，寻找以arr[i]为最小值的子数组中累加和最大的一个，该过程等效于寻找arr[i]两侧比其更小的最近元素：

1. 对于arr[0] = 5 来说，其左侧最近min 不存在，右侧最近min = 3，因此查询子数组就是[5]
2. 对于arr[1] = 3 来说，其左侧最近min 不存在，右侧最近min = 2，因此查询子数组是[5,3]
3. 对于arr[2] = 2 来说，其左侧最近min 不存在，右侧最近min = 1，因此查询子数组是[5,3,2]
4. 对于arr[3] = 1 来说，其左侧最近min 不存在，右侧最近min 不存在，因此查询子数组是[5,3,2,1,6,7,8,4]
5. 对于arr[4] = 6 来说，其左侧最近min = 1，右侧最近min = 4，因此查询子数组是[6 7 8]
6. 对于arr[5] = 7 来说，其左侧最近min = 6，右侧最近min = 4，因此查询子数组是[7 8]
7. 对于arr[6] = 8 来说，其左侧最近min = 7，右侧最近min = 4，因此查询子数组是[8]
8. 对于arr[7] = 4 来说，其左侧最近min = 1，右侧最近min不存在，因此查询子数组是[6 7 8 4]