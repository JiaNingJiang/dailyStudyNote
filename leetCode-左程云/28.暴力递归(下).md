## 一、题目一

下象棋问题：棋盘一行有9格，一列有10格。现在要求操作马，从(0,0)位置（棋盘的左下角）走K步到达(x,y)位置，请给出走法数。

### 1.1 解法一：暴力DP

```go
func process(x,y,step int) int {
    if (x<0||x>8||y<0||y>9){  // 边界条件:棋盘越界
        return 0
    }
    // 当步数=0时，当且仅当目的地就是(0,0)才算一种可行的走法
    if (step == 0) {
        return (x==0 && y==0) ? 1:0
    }
    // 要到达的位置不越界，且还有步数可以跳(注意：马是走日的，求step步到达(x,y)，也就是求step-1到达下面八个位置)
    return process(x-1,y+2,step-1)
    		+process(x+1,y+2,step-1)
    		+process(x+2,y+1,step-1)
    		+process(x+2,y-1,step-1)
    		+process(x+1,y-2,step-1)
    		+process(x-1,y-2,step-1)
    		+process(x-2,y-1,step-1)
    		+process(x-2,y+1,step-1)
}
```

### 1.2 解法二：严格表结构

问题有三个参变量：横坐标x、纵坐标y、剩余步数step。

构建一个三维坐标系，x轴就是x，y轴就是y，z轴就是step。

1. 我们的目标求解值是位于 z = step 平面上的(x,y)点。
2. 现在已知的是z = 0平面上(0,0)的返回值是1，其余所有点的返回值都是0
3. 剩余正常情况：当前z = step平面的(m,n)依赖于z = step-1平面上的八个点。

求解的顺序就是通过 z =0 平面逐渐推得 z =1 到 z = step-1各点的值，最后根据z = step -1 平面的八个点获取 z = step平面(x,y)点的值。

```go
func dpWay(x,y,step int) int {
    if (x < 0 || x > 8 || y < 0 || y > 9 || step < 0) {
        return 0
    }
    int[][][] dp = new int[9][10][step+1]
    dp[0][0][0] = 1
    for h:=1 ; h<=step ; h++{   // 1~step层，从低到高
        for r:=0 ; r < 9 ; r++ {
            for c:=0 ; c < 10 ; c++ {
                dp[r][c][h] += getValue(dp,r-1,c+2,h-1)
                dp[r][c][h] += getValue(dp,r+1,c+2,h-1)
                dp[r][c][h] += getValue(dp,r+2,c+1,h-1)
                dp[r][c][h] += getValue(dp,r+2,c-1,h-1)
                dp[r][c][h] += getValue(dp,r+1,c-2,h-1)
                dp[r][c][h] += getValue(dp,r-1,c-2,h-1)
                dp[r][c][h] += getValue(dp,r-2,c-1,h-1)
                dp[r][c][h] += getValue(dp,r-2,c+1,h-1)
            }
        }
    } 
    return dp[x][y][step]
}

func getValue(dp [][][]int, row int,col int,step int) {
    if (row < 0 || row > 8 || col < 0 || col > 9) {
        return 0
    }
    return dp[row][col][step]
}
```

## 二、题目二

### 2.1 解法一：暴力DP

在一个N*M的区域上，Bob从（row，col）位置出发，走rest步之后，仍然生存的概率（生存是Bob在走完rest步时从未越过界）

```go
func BobLiveRate(N,M,row,col,rest int) float {
    allCase := math.Pow(4,rest)  // 总的情况数量，每次都有4种走法，一共走k步
    return process(N,M,row,col,rest)/allCase
}

func process(N,M,row,col,rest int) long {
    // 越界即是死
    if (row < 0 || row == N || col < 0 || col == M) {
        return 0
    }
    // row,col没有越界，且步数走完
    if rest == 0 {
        return 1
    }
    // 还没走完，row、col也没越界
    var live long
    live += process(N,M,row-1,col,rest-1)
    live += process(N,M,row+1,col,rest-1)
    live += process(N,M,row,col-1,rest-1)
    live += process(N,M,row,col+1,rest-1)
}
```

### 2.2 解法二：严格表结构