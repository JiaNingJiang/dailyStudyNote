### 一、什么是贪心算法

​	贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。
 	贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。
 	贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。



下面给出一个贪心算法最简单的应用实例：

> 问题：在N行M列的正整数矩阵中，要求从每一行中选出一个数，使得选出数的总和最大。
> 分析：思路很简单，选择N次，每次从当前行选出最大值，最后相加即可。其实这就是一种贪心策略。要求使总和最大，那么我们把这个问题分解成若干个子问题，即求每一个子问题的最优解，汇总后得到大问题的最优解。

求解图问题的`Prim`算法和`Dijkstra`算法都是贪心算法。

### 二、贪心算法解题思路

1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2. 脑补出贪心策略A、B、C……
3. 用解法X和对数器，去验证每一个贪心策略，用实验的方法得知哪个贪心算法正确
4. 不要去纠结贪心策略的证明

### 三、会议室问题

​	一些项目要占用一个会议室进行宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回这个最多的宣讲场次。

> 针对这个问题的贪心算法是：每次选择一个时间不冲突的最早结束的会议

```go
type Program struct {
    start int   // 会议开始时间
    end int  // 会议结束时间
}

// programs记录所有会议；timePoint记录可以开始会议的最早时间
func bestArrange(programs []Program,timePoint int) int {
    Arrays.sort(programs,new ProgramComparator())  // 将所有的会议按照结束早晚进行排序
    result := 0
    // 从小到大遍历所有会议
    for i:=0;i<len(programs);i++ {
        if timePoint <= programs[i].start {  // 符合条件的会议
            result++
            timePoint = programs[i].end  // 添加了一场新会议，更新timePoint
        }
    }
	return result
}
```

