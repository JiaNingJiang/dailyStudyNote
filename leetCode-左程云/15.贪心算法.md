### 一、什么是贪心算法

​	贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。
 	贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。
 	贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。



下面给出一个贪心算法最简单的应用实例：

> 问题：在N行M列的正整数矩阵中，要求从每一行中选出一个数，使得选出数的总和最大。
> 分析：思路很简单，选择N次，每次从当前行选出最大值，最后相加即可。其实这就是一种贪心策略。要求使总和最大，那么我们把这个问题分解成若干个子问题，即求每一个子问题的最优解，汇总后得到大问题的最优解。

求解图问题的`Prim`算法和`Dijkstra`算法都是贪心算法。

### 二、贪心算法解题思路

1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2. 脑补出贪心策略A、B、C……
3. 用解法X和对数器，去验证每一个贪心策略，用实验的方法得知哪个贪心算法正确
4. 不要去纠结贪心策略的证明

### 三、会议室问题

​	一些项目要占用一个会议室进行宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回这个最多的宣讲场次。

> 针对这个问题的贪心算法是：每次选择一个时间不冲突的最早结束的会议

```go
type Program struct {
    start int   // 会议开始时间
    end int  // 会议结束时间
}

// programs记录所有会议；timePoint记录可以开始会议的最早时间
func bestArrange(programs []Program,timePoint int) int {
    Arrays.sort(programs,new ProgramComparator())  // 将所有的会议按照结束早晚进行排序
    result := 0
    // 从小到大遍历所有会议
    for i:=0;i<len(programs);i++ {
        if timePoint <= programs[i].start {  // 符合条件的会议
            result++
            timePoint = programs[i].end  // 添加了一场新会议，更新timePoint
        }
    }
	return result
}
```

### 四、切金条问题

假设将一根金条切成两半，是需要花费和金条长度相同的钱。比如，一根80cm的金条，切成两半，需要花80块钱。现在，一群人想分一整块金条，每个人分得的长度保存在一个数组中，例如[10，20，30]意思就是将一根60cm的金条，划分成10，20，30三段，请问，怎样切分最省钱？
例如：
先将金条切分成10和50，需要60块钱，然后，再将50切分成20和30，需要50块，总共需要110块钱。
又或者，先将金条切分成30和30，花60块钱，然后再将30切分成10和20，花30块钱，总共就是90块钱。
90<110，所以第二种划算。

> 思路：
>
> 首先，观察题目，可以发现，每切一次，只能切出来一段最终结果，另一端肯定还有继续切割，这一段最终结果是不需要再次切分了，也就说明，后面切分时就不需要再算这一段的钱了，因此，这一段最终结果的数值越大，总的代价就越小。也就是说，我们先把大的切出来，越省钱，大的不会再次计算价钱了，越小的，我们最后切出来。
> 因此，从上面分析出来的结果可以看出，其实，本质就是，减少数值大的遍历次数，增加数值小的遍历次数，这样总体代价最低。



> 哈夫曼树
> 这样的贪心算法有一种数据结构能够轻松实现，那就是哈夫曼树，哈夫曼树的构建过程，就是先把最小的两个相连，然后组成一个新节点，然后放入总的集合中，再从中找出最小的两颗子树再次相连，再将结果放入集合中，最终集合中只剩下一棵树，这棵树就是哈夫曼树。这道题其实就是哈夫曼树的应用。



> 小根堆
> 此题用哈夫曼树解决，为什么会提到小根堆呢？因为，哈夫曼树的构建过程，每次需要将两个子树合成的结果再次放入集合中，然后，再从集合中取出两个最小值。这个过程，如果用常规数组的话，每次放入后，是不是还需要再次排序呀？这个再次排序的过程，是不是小根堆效率很好啊？只需要调整小根堆就行了，最多logn，如果是一般方法，是不是每次都需要重新排序，效率极低的。



> **最终解题思路**
>  先将数组构建成小根堆，然后，从小根堆中弹出两个。把这两个加在总和money上，然后这两个数相加，相加后，再次入小根堆。然后再从中弹出两个最小值，重复上述操作，直到小根堆中只剩一个数，结束，计算money。

```go
func lessMoney(arr []int) int {
    pQ := new(PriorityQueue)  // 小根堆
    for i:=0;i<len(arr);i++ {
        pQ.add(arr[i])
    }
    sum := 0
    cur := 0
    for {
        if pQ.size() <= 1 {
            break
        }
        cur = pQ.poll() + pQ.poll()  // 每次从小根堆弹出两个数
        sum += cur // 累加话费的money
        pQ.add(cur)   // 填充1个两小数之和
    }
    return sum
}
```

### 五、获取最大项目收益问题

输入：

1. 正数数组 costs
2. 正数数组 profits
3. 正数 k
4. 正数 m

含义：

1. costs[i] 表示i号项目的花费
2. profits[i] 表示i号项目在做完之后能够得到的收益
3. k表示你最多只能做k个项目
4. m表示你的初始资金

说明：

​	你每做完一个项目，马上获取的收益，可以支持你去做下一个项目。

输出：

​	你最后获得的最大钱数。

> 思路：
>
> 1. 先按照项目花费的钱数，将项目按照小根堆方式进行排列
> 2. 从小根堆中弹出所有花费 < 当前所有资金 的项目
> 3. 将弹出的项目按照收益的大小，按照大根堆方式排列
> 4. 每次从大根堆中弹出一个项目，将获取的收益加到初始资金m上

```go
func findMaxizedCaptital(k,m int,Profits []int,Costs []int) {
    minCostQ := new(PriorityQueue) // 项目花费的小根堆
    maxProfitQ := new(PriorityQueue) // 项目利润的大根堆
    
    for i:=0;i<len(Profits);i++ {
        minCostQ.add(Node(Profits[i],Capital[i]))
    }
    for i:=0;i<k;i++ {
        for {
            // 仅当项目花费小根堆不为空 且 项目花费小根堆 根节点的话费小于当前资金时，才能进行项目解锁(做该项目来获取利润)
            if !minCostQ.isEmpty() && minCostQ.top().cost <= W {
                maxProfitQ.add(minCostQ.poll())
            }
        }
        // 中途发现无项目可做(资金不够，接不了项目)，直接退出，返回总共的资金
        if maxProfitQ.isEmpty() {
            return W
        }
        W += maxProfitQ.poll().profit
    }
    return W
}
```

### 六、数据流中位数问题

问题：接受用户的数据流，要求随时能够给用户返回当前已有数据的中位数。

> 思路：
>
> 1. 准备一个大根堆和一个小根堆
> 2. 对于数据流的第一个数，将其放入到大根堆中。
> 3. 对于之后的数，需要判断此数与大根堆堆顶数值的大小：如果新数 > 大根堆堆顶，将该数放入小根堆；如果新数 <= 大根堆堆顶，将该数放入小根堆中。
> 4. 一旦大小根堆元素数量之差等于2，将元素数量多的根堆的堆顶元素从原根堆转移到另一个根堆。
>
> 上述的流程，可以保证大根堆总是存储 前 N/2个 数据，小根堆总是存储后N/2个元素。且中位数总是在大小根堆的堆顶。（奇数个数有唯一的中位数，偶数个的时候将大小根堆的堆顶元素取平均值）

### 七、N皇后问题 

[八皇后问题](https://so.csdn.net/so/search?q=八皇后问题&spm=1001.2101.3001.7020)是十九世纪著名的数学家高斯于1850年提出的。:在8×8的棋盘上摆放八个皇后，使其不能互相攻击，即**任意两个皇后都不能处于同一行、同一列或同一斜线上**。可以把八皇后问题扩展到n皇后问题，即在n×n的棋盘上摆放n个皇后，使任意两个皇后都不能处于同一行、同一列或同一斜线上。 

<img src="15.贪心算法.assets/image-20230411202107369.png" alt="image-20230411202107369" style="zoom:50%;" />

### 7.1 经典解法

```go
// 参数n表示要求解几皇后问题，返回值是解法数量
func num1(n int) int {
    if n < 1 {
        return 0
    }
    record := make([]int,n,n)  // record[i] = k表示第i行的皇后，放在第k列
    return process1(0,n,record)
}

// 目前来到了第i行
// record[0...i-1]表示之前的行，放了皇后的位置
// n表示整体一共有多少行
// 返回值是：摆完所有的皇后，合理的摆法有多少种
func process1(i,n int,record []int) int {
    if i==n {  // 0~n-1行完成了N皇后问题，返回解法数量+1
        return 1
    }
    res := 0
    for j:=0;j<n;j++ {//当前行在第i行，尝试第i行的所有列
        // 当前第i行的皇后，放在第j列，会不会和之前(0...i-1)的皇后：共行共列或者共斜线
        // 如果是，认为无效
        // 如果不是，认为有效
        if isValid(record,i,j) {
            record[i] = j
            res += process1(i+1,record,n)  // 完成验证，继续摆放第i+1行
        }
    }
    return res
}

func isValid(record []int,i,j int) bool {
    for k:=0;k<i;k++{
        // 共列或者共斜线(共斜线 --> 列数之差 == 行数之差)
        if j == record[k] || math.Abs(record[k]-j) == math.Abs(i-k) {
            return false
        }
    }
    return true
}
```



### 7.2 优化常数项后的解法

采用位运算可以优化上述的N皇后问题解法。在N=15及之后时两种方法实际消耗的时间有明显差距。

> 思路:
>
> 一个数可以表示为二进制形式，我们以8皇后问题为例：
>
> 在第0行，假设我们将皇后摆在首位，那么用二进制表示改行为：...(前面的若干个0) 1000 0000。前面的若干个0取决于具体的变量，比如int默认为32bit，因此这个若干个就是24个。
>
> 那么我们对于第1行的列限制就是 (24个0) 1000 000 ，左对角线限制就是 (24个0) 0000 000，右对角线限制就是(24个0) 0100 000。总共的限制就是(24个0) 1100 000，也就是说第一行此时只能选择后6位。
>
> 通过这样的方式，我们可以不再通过使用record数组，而是仅仅用一个变量就能确定下一行皇后的摆放限制。

```go
func num2(n int) int {
    if (n < 1 || n >32) {  // 因为使用的辅助数是int,只有32位,如果想要解决更大的N皇后问题,可以改用int64...
        return 0
    }
    var limit int   // limit用来做位数的限制，比如8皇后问题,对于辅助数int就只能考虑后八位。通过将辅助数与limit做按位与来实现这种保证
    if n == 32 {
        limit = 1
    }else {
        limit = (1 << n) - 1
    }
    return process2(limit,0,0,0)
}

// colLim 列的限制，1的位置不能放皇后，0的位置可以
// leftDiaLim 左对角线的限制，1的位置不能放皇后，0的位置可以
// rightDiaLim 右对角线的限制，1的位置不能放皇后，0的位置可以
func process2(limit,colLim,leftDiaLim,rightDiaLim int) int {
    if colLim == limit {  // 所有的N行都填了皇后，因此该方法可行，解法+1
        return 1
    }
    pos := limit & (~(colLim | leftDiaLim | rightDiaLim))  // 下一行所有可以填皇后的位置都为1（具有记忆性，会不断积累前面i-1行产生的影响）
    res := 0
    for {
        if pos == 0 {  // 下一行无处可放皇后
            break
        }
        mostRightOne := pos & (~pos + 1) // 取出pos最右侧的1(二进制位)
        pos = pos - mostRightOne  // 消去最右侧的1
        res += process2(limit, colLim|mostRightOne,  // 行数限制累积
                        (leftDiaLim|mostRightOne)<<1,  // 左对角线限制累积(完全正确的)
                        (rightDiaLim|mostRightOne)>>1)  // 右对角线限制累积
    }
    return res
    
}
```

