![image-20231223131659149](04.内存空间的分配—连续分配方式.assets/image-20231223131659149.png)

# 一、单一连续分配

![image-20231223131742985](04.内存空间的分配—连续分配方式.assets/image-20231223131742985.png)

# 二、固定分区分配

![image-20231223131816482](04.内存空间的分配—连续分配方式.assets/image-20231223131816482.png)

![image-20231223131903048](04.内存空间的分配—连续分配方式.assets/image-20231223131903048.png)

# 三、动态分区分配

![image-20231223131957127](04.内存空间的分配—连续分配方式.assets/image-20231223131957127.png)

![image-20231223132602825](04.内存空间的分配—连续分配方式.assets/image-20231223132602825.png)

## 3.1  记录内存的使用情况

![image-20231223132037385](04.内存空间的分配—连续分配方式.assets/image-20231223132037385.png)

## 3.2  动态分区分配算法

![image-20231223132116027](04.内存空间的分配—连续分配方式.assets/image-20231223132116027.png)

![image-20231223132806273](04.内存空间的分配—连续分配方式.assets/image-20231223132806273.png)

### 3.2.1  首次适应算法

![image-20231223132944761](04.内存空间的分配—连续分配方式.assets/image-20231223132944761.png)

### 3.2.2  最佳适应算法

![image-20231223133054943](04.内存空间的分配—连续分配方式.assets/image-20231223133054943.png)

每次分配后，某一块分区的分区大小可能会发生变化，此时需要重新对空闲分区表（链）按照容量进行排序。

![image-20231223133220368](04.内存空间的分配—连续分配方式.assets/image-20231223133220368.png)

### 3.2.3 最坏适应算法

![image-20231223133309182](04.内存空间的分配—连续分配方式.assets/image-20231223133309182.png)

同样，在完成分配后，需要对空闲分区表（链）进行重新排序。

![image-20231223133400724](04.内存空间的分配—连续分配方式.assets/image-20231223133400724.png)

### 3.2.4 邻近适应算法

![image-20231223133437791](04.内存空间的分配—连续分配方式.assets/image-20231223133437791.png)

![image-20231223133524192](04.内存空间的分配—连续分配方式.assets/image-20231223133524192.png)

### 3.2.5  小结

![image-20231223133545375](04.内存空间的分配—连续分配方式.assets/image-20231223133545375.png)

## 3.3  分区的回收

回收时需要注意合并：

1. 回收区前后都没有相邻空闲分区，不需要合并
2. 回收区前面/后面是空闲分区，进行合并
3. 回收区前后都是相邻的空闲分区，进行合并

# 四、总结

![image-20231223132651641](04.内存空间的分配—连续分配方式.assets/image-20231223132651641.png)