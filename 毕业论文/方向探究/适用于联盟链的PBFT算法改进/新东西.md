[1]鲁意. 区块链PBFT共识算法的可扩展性优化研究与实现[D].南京邮电大学,2022.DOI:10.27251/d.cnki.gnjdc.2022.000230.



1. 聚合签名是什么？  `Boneh-Lynn-Shacham (BLS)` 签名方案  -- > 在哪里发挥作用？

   1. ~~主要是在主节点将收集到的2*f+1条数字签名广播时，用处比较大，因为其他副本节点只需要对聚合签名验证一次即可，不需要对 2 * f+1条数字签名验证，减少了验证时间。~~
   2. 聚合签名将多个签名压缩，可以减少占用的存储空间（但是具体减少的多少需要实验）

2. 交易聚合技术？将多个交易合并为一个，一个交易聚合者（通常是矿工或交易池）从已广播的交易中选择要进行聚合的交易。选择的依据可能包括交易费用、交易大小或其他优先级标准。需要注意的是，交易聚合并不适用于所有类型的交易。**通常，只有相互独立且没有先后关系的交易才可以被聚合**。一些常见的应用包括批量转账、多个用户的合约互动等。

3. reply阶段：以下两种方式哪一种更好？

   1. 对于commit区块内的交易，每个副本节点都需要把交易执行，然后把执行结果发送给主节点，主节点同时收到 2*f条相同的执行结果，才能修改世界状态，并且要通知副本节点进行相同的修改。 （安全性更高？）
   2. 对于commit区块内的交易，直接由主节点完成所有交易的执行，完成本地世界状态的变化之后，把执行的交易按照顺序以区块形式打包发送给副本节点，让副本节点修改世界状态。（可用性更高？）

4. 仔细思考副本节点启动`view-change`的情况，目前只考虑了主节点宕机的情况，比如：长期未收到主节点的`pre-prepare`或者心跳包。没有考虑主节点是拜占庭节点的情况，在这种情况下，改论文考虑从以下节点入手（**考虑了主节点针对某一特定阶段进行恶意进攻的情况**）：

   <img src="新东西.assets/image-20230719153110491-16897518829641.png" alt="image-20230719153110491" style="zoom:50%;" />

   但其实无论是主节点宕机引起的共识失效还是主节点是拜占庭节点引起的失效，都可以把**距离最近一次产生新区块的时间间隔是否超过了指定时长**作为一个统一的检测标准，因为这两种情况都会导致整个网络无法产生最新的区块。

5. 新的主节点拒绝接收**小于当前区块链最高块高度**的`view-change`消息，可以防止已经失效的节点对系统造成影响。
6. `view-change`消息中可以包含尚未完成共识的`pre-prepare`消息和`prepare`消息，这样可以在完成`view-change`后迅速回复对上一轮未完成共识的重启。（是否可以考虑把本地的`commit`消息也包含进入？）
7. 跟随节点在验证新主节点的`new-view`消息时也可以采用聚合签名验证的方法。
8. 动态调整`view-change`的启动间隔时间：

​	<img src="新东西.assets/image-20230719160107713.png" alt="image-20230719160107713" style="zoom:50%;" />



9. `PBFT`改成O(N)通信复杂度：

   1. `pre-prepare`阶段通信复杂度就是O(N)不需要该；

   2. `prepare`阶段因为每个节点都需要广播，因此复杂度是O(N^2)，如果改成只发送给主节点就可以改成O(N);
   3.  `commit`阶段因为每个节点都需要广播，因此复杂度为O(N^2)，如果改成只由Leader节点将需要执行的交易（**其他节点可以验证交易是存在的且不重复的**）发送给其他节点可以变成O(N)；
   4. `reply`阶段原本需要每个节点都向客户端回复，因此的复杂度是O(N)，如果改成仅由`Leader`回复可以变成O(1)，但是这样安全性没有保障(`Leader`权利太大)，因此`reply`阶段最好还是由N个节点负责向客户端回复某笔交易的执行结果，从而防止`Leader`的虚假交易执行结果出现(交易可以根据`txID`锁定)。
   5. 这样一来，总的通信复杂度是 O(N) + O(N) + O(N) + O(N) = O(N)
10. 因为不是双层共识，这里就让每一个节点执行完交易后，自行组装区块存储到本地。如果网络节点都正常的话因为都是状态机，所有节点生成的区块应该就是一模一样的。
11. 针对某些节点可能出现区块落后的问题，可以为每一个节点安装区块同步模块。区块同步模块可以主动向其他节点发送同步请求，这里可以设置一个基于信誉的同步机制，避免从恶意节点处同步到区块。比如：只有当一个区块在全网的2*f+1个节点上存在时(简单起见，查看区块哈希即可)，才会将其同步过来。
12. **`view-change`的复杂度那一块没看懂**
13. 世界状态的存储：k-v结构 VS MPT树，表型结构是用空间换时间，这也是现今高流量应用的主流策略。
14. 性能测试：

    1. 通信复杂度的实验验证：在规定的时间内，看共识完成的轮次即可进行评估。
    2. 通信成本的验证：固定节点数目，计算完成一轮共识的KB大小（只包含一笔交易的情况下）
    3. 吞吐量分析：规定的节点数下，固定的区块大小和交易量下`TPS`的测量
    4. 延迟分析：固定区块大小，分析不同节点数量时的共识延迟；固定节点数量，不同区块大小时节点的共识延迟。
15. 拜占庭节点：VBFT假设一个自适应对手。对手可以在**多项式时间内**使任何正常节点变为拜占庭节点，并且可以完全控制和协调所有拜占庭节点。**拜占庭节点不仅可以相互协调，还可以以任意方式偏离协议。**例如，拜占庭节点可以**发送无效或不一致的消息、丢弃消息、不响应消息**。**一旦算法运行，分片内拜占庭节点的数量是固定的。**

16. 分片PBFT共识：将客户端的请求进行分片，分发给若干个PBFT共识群组，各群组完成共识并执行请求后将结果返回给"最终共识委员会"再进行一次共识，生成区块并将最终的结果返回给客户端。针对这一点的思考：

    1. 客户端请求分片再分发可以引入负载均衡？(根据各分区的处理能力合理分配请求数)
    2. 对于又先后依赖关系的交易最好都在同一个PBFT群组执行共识（合理的分片策略就有说法了），如果被分配到不同分区可能在交易执行阶段会出现某些错误？

17. 如果有3个PBFT分区，每个分区有4个节点。假设破坏者可以操作任意3个节点变成拜占庭节点。分析：

    1. 拜占庭分布情况：1 1 1，这样所有分区都能正常运行。
    2. 拜占庭分布情况：2 1 0，有两个拜占庭节点的分区无法正常运行。
    3. 拜占庭分布情况：3 0 0，有三个拜占庭节点的分区无法正常运行。

    根据上述分析结果，可知：拜占庭节点被均匀分布时可以使系统的抗毁性最高。

    要做到这一点，就需要每个节点加入网络被分配到分区是完全随机的(概率是1/3)。

    ```
    该论文的策略是：
    1.先在全网选出一个领导者节点（并不是让节点自己决定加入到哪一个分区），方法是通过可验证随机函数选择领导者节点
    2.领导节点生成一个随机种子rand，决定其余节点应该加入到哪一个分区。
    3.rand隔一段时间就重新生成，重新分配节点到分区。
    ```

    ```
    这种方式确实很安全，但是效率相对而言就变低了，在相同的时间段内用于共识的占比就变少了。
    所以可能需要根据使用的场景调整rand生成的时间间隔。
    ```

    



17. PBFT的`view-change`中，新的`Leader`节点是谁是可以被预测出来的，因此`Leader`可能会成为重点攻击的对象。因此这样方法可以说是：效率高，但是安全性低；另一种方法是：新`Leader`的选举完全随机，这样破坏者完全无法预料到下一轮的`Leader`是谁，这种方法：安全性高，但势必要增加额外的通信流程，效率自然就低；折中的想法是：牺牲一定的随机性，也就是说不是完全均匀随机，有些节点成为下一轮`Leader`的概率会高一点，但是不是概率为1。
