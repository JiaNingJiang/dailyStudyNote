设计模式根据其目的可以分为三大类：创建型（Creational）、结构型（Structural）和行为型（Behavioral）。每种类型的设计模式都有其独特的特征和适用场景。以下是对这三类设计模式的概述：

### 创建型设计模式 (Creational Patterns)

**特征**：
- 关注对象的创建过程，旨在将对象的创建与使用分离。
- 提供了一种**控制对象创建**的方式，使得系统更加灵活、易于维护。

**常见模式**：
1. **单例模式 (Singleton)**：确保一个类只有一个实例，并提供一个全局访问点。
2. **工厂方法模式 (Factory Method)**：定义一个用于创建对象的接口，但让子类决定实例化哪一个类。
3. **抽象工厂模式 (Abstract Factory)**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
4. **建造者模式 (Builder)**：允许分步骤构造复杂对象，同样的构建过程可以创建不同的表示。
5. **原型模式 (Prototype)**：通过复制现有对象来创建新对象，而不必重新经历创建过程。

**适用场景**：
- 当创建对象的成本较高时，或者需要对对象创建进行更多控制的时候。
- 需要管理资源，如数据库连接池、线程池等。
- 对象创建逻辑复杂，包含许多可选配置或步骤。

### 结构型设计模式 (Structural Patterns)

**特征**：
- 关注如何**组合类或对象以形成更大的结构**。
- 通常**涉及对象组合而不是继承**，从而实现更灵活的设计。

**常见模式**：
1. **适配器模式 (Adapter)**：使不兼容的接口能够协同工作。
2. **桥接模式 (Bridge)**：将抽象部分与它的实现部分分离，使它们都可以独立变化。
3. **组合模式 (Composite)**：允许你将对象组合成树形结构来表示“部分-整体”的层次结构。
4. **装饰模式 (Decorator)**：动态地给一个对象添加一些额外的职责，而不影响其他对象。
5. **外观模式 (Facade)**：为复杂的子系统提供一个简化的接口。
6. **享元模式 (Flyweight)**：通过共享尽可能多的数据来有效地支持大量细粒度的对象。
7. **代理模式 (Proxy)**：为另一个对象提供一个替身或占位符以控制对这个对象的访问。

**适用场景**：
- 当你需要简化复杂系统的接口，或者想要解耦组件之间的依赖关系。
- 组织代码结构，使之更加模块化、易于扩展。
- 处理不同层次的对象组合问题，例如UI控件树、文件目录结构等。

### 行为型设计模式 (Behavioral Patterns)

**特征**：
- 关注**对象之间的通信**，即它们的**责任分配以及协作方式**。
- 强调对象间的行为和算法，而非静态结构。

**常见模式**：
1. **责任链模式 (Chain of Responsibility)**：避免请求发送者与接收者耦合，多个对象都有机会处理请求。
2. **命令模式 (Command)**：将请求封装成对象，从而使你可以用不同的请求对客户进行参数化。
3. **解释器模式 (Interpreter)**：给定一种语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
4. **迭代器模式 (Iterator)**：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露其内部表示。
5. **中介者模式 (Mediator)**：用一个中介对象来封装一系列的对象交互。
6. **备忘录模式 (Memento)**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
7. **观察者模式 (Observer)**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知并自动更新。
8. **状态模式 (State)**：允许一个对象在其内部状态改变时改变它的行为。
9. **策略模式 (Strategy)**：定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。
10. **模板方法模式 (Template Method)**：定义一个操作中的算法框架，而将一些步骤延迟到子类中实现。
11. **访问者模式 (Visitor)**：表示一个作用于某对象结构中的各元素的操作，可以在不改变各元素类的前提下定义新的操作。

**适用场景**：
- 管理对象间的交互，特别是当你希望降低这些对象之间的耦合度。
- 实现算法或行为的灵活性，比如策略选择、状态切换等。
- 支持事件驱动架构，如GUI应用中的用户交互。

总的来说，了解这三种类型的设计模式及其特点可以帮助开发者更好地选择合适的设计模式来解决特定的问题，提高软件的质量和可维护性。