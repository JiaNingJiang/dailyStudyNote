**问题**：

当你有**两个不兼容的接口（即类或对象）**，但需要它们能够一起工作时，适配器模式可以解决这个问题。例如，你可能**有一个已存在的类库或组件，但其接口与你的代码不匹配**，你希望能够无缝地将它们集成在一起。

**解决方案**：

适配器模式通过**引入一个适配器类来充当中间人**，**将一个接口转换成另一个接口**，使得两个不兼容的对象能够协同工作。**适配器类包含一个对不兼容接口的引用，并实现了你期望的目标接口**。这样，当你需要使用目标接口的时候，可以通过适配器来调用原本不兼容的类的方法。

**效果**：

适配器模式的应用可以使得现有的代码与新代码能够无缝协同工作，从而提高了代码的可重用性。它允许你将不同系统、库或组件整合在一起，而无需对现有代码进行大量修改。然而，适配器模式也可能引入一些复杂性，因为你需要维护适配器类和处理不同接口之间的映射关系。

总的来说，适配器模式是一种很有用的模式，特别适合在集成不同组件或类时，解决接口不匹配的问题，从而保持代码的灵活性和可维护性。

**代码示例：**

适配器模式可以通过两种主要的方式实现：**对象适配器**和**类适配器**。

**对象适配器**

对象适配器**使用组合的方式**来包含一个被适配者的实例。这种方式更加灵活，因为它不需要修改被适配者的源代码，并且可以在运行时动态地选择不同的被适配者。

```java
// 目标接口
public interface Target {
    void request();
}

// 被适配者
public class Adaptee {
    public void specificRequest() {
        System.out.println("Adaptee's specific request.");
    }
}

// 对象适配器
public class Adapter implements Target {
    private Adaptee adaptee;

    // 构造函数中传入被适配者
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        // 将请求转换为特定请求
        adaptee.specificRequest();
    }
}
```

**类适配器：**

类适配器则是**通过多重继承来实现适配功能**，即适配器类同时**继承自目标接口**并**实现被适配者的接口或扩展被适配者的类**。然而，在Java等不支持多继承的语言中，这通常意味着**适配器类需要继承被适配者并且实现目标接口**。

```java
// 如果语言支持多继承，则可以直接继承Adaptee并实现Target接口
public class ClassAdapter extends Adaptee implements Target {
    @Override
    public void request() {
        // 将请求转换为特定请求
        super.specificRequest();
    }
}
```

**适配器类的特点**

- 解耦合：适配器类减少了客户端代码与具体实现之间的依赖，使得系统更易于维护和扩展。
- 复用性：可以利用现有的类而无需修改它们，提高了代码的复用率。
- 灵活性：对于对象适配器来说，它提供了更大的灵活性，因为可以在运行时决定要适配哪个类。

**双向适配器**

有时候，我们可能需要双向适配，即**不仅可以让Target使用Adaptee的功能**，**还可以让Adaptee使用Target的功能**。这可以通过**创建两个适配器来实现**，每个适配器负责一个方向上的适配。



**适用场景**

适配器类适用于以下几种情况：

- 当你希望使用一些现有的类，但是它们的接口不符合你的需求时。
- 当你想创建一个可以重复使用的类，它可以与其他不兼容的类或接口协同工作。
- 在开发框架或库时，为了保证与各种外部组件的兼容性，适配器类非常有用。
- 当你**需要更改已有子类的接口**时，适配器类可以作为替代方案，而**不是直接修改子类**。



总之，适配器类是解决不同接口之间不兼容问题的有效工具，特别是在需要**整合旧有代码或者第三方库的时候**。它通过**提供一个中间层**，使得不同接口的对象能够无缝协作。

