# 一、Java 支持的变量类型

Java 语言支持的变量类型有：

1. **局部变量（Local Variables）：**局部变量是在方法、构造函数或块内部声明的变量，它们在声明的方法、构造函数或块执行结束后被销毁，局部变量**在使用前需要初始化，否则会导致编译错误**。

```java
public void exampleMethod() {
    int localVar = 10; // 局部变量
    // ...
}
```

2. **实例变量（Instance Variables）：**实例变量是在类中声明，但在方法、构造函数或块之外，它们**属于类的实例**，**每个类的实例都有自己的副本**，如果**不明确初始化，实例变量会被赋予默认值**（数值类型为0，boolean类型为false，对象引用类型为null）。

```java
public class ExampleClass {
    int instanceVar; // 实例变量
}
```

3. **静态变量或类变量（Class Variables）：**类变量是在**类中用 static 关键字声明的变量**，它们**属于类而不是实例**，所有**该类的所有实例共享同一个类变量的值**，类变量在类加载时被初始化，而且**只初始化一次**。

```java
public class ExampleClass {
    static int classVar; // 类变量
}
```

4. **参数变量（Parameters）：**参数是**方法或构造函数声明中的变量**，用于接收调用该方法或构造函数时传递的值，参数变量的**作用域只限于方法内部**。

```java
public void exampleMethod(int parameterVar) {
    // 参数变量
    // ...
}
```

# 二、Java 参数变量

Java 中的参数变量是指在方法或构造函数中声明的变量，用于接收传递给方法或构造函数的值。参数变量与局部变量类似，但它们只在方法或构造函数被调用时存在，并且只能在方法或构造函数内部使用。

在调用方法时，我们必须为参数变量传递值，这些值可以是常量、变量或表达式。

方法参数变量的值传递方式有两种：**值传递**和**引用传递**。

- **值传递：**在方法调用时，传递的是**实际参数的值的副本**。当参数变量被赋予新的值时，只会修改副本的值，**不会影响原始值**。Java 中的**基本数据类型**都采用**值传递**方式传递参数变量的值。
- **引用传递：**在方法调用时，传递的是**实际参数的引用（即内存地址）**。当参数变量被赋予新的值时，**会修改原始值的内容**。Java 中的**对象类型**采用**引用传递**方式传递参数变量的值。

# 三、Java 局部变量

Java 的局部变量是在方法、构造方法或语句块内部声明的变量，其作用域限制在声明它的代码块内部。

**说明：**

- **作用域**：局部变量的作用域限于它被声明的方法、构造方法或代码块内。一旦代码执行流程离开这个作用域，局部变量就不再可访问。
- **生命周期**：局部变量的生命周期从声明时开始，到方法、构造方法或代码块执行结束时终止。之后，局部变量将被垃圾回收。
- **初始化**：局部变量在**使用前（注意：是在使用前，即定义和赋值可以分开）必须被初始化**。如果**不进行初始化，编译器会报错**，因为 **Java 不会为局部变量提供默认值**。
- **声明**：局部变量的声明必须在方法或代码块的开始处进行。声明时可以指定数据类型，后面跟着变量名，例如：`int count;`。
- **赋值**：局部变量在声明后必须被赋值，才能在方法内使用。赋值可以是直接赋值，也可以是通过方法调用或表达式。
- **限制**：局部变量**不能被类的其他方法直接访问**，它们只为声明它们的方法或代码块所私有。
- **内存管理**：局部变量**存储在 Java 虚拟机（JVM）的栈上**，与存储在堆上的实例变量或对象不同。
- **垃圾回收**：由于局部变量的生命周期严格限于方法或代码块的执行，它们在方法或代码块执行完毕后不再被引用，因此JVM的垃圾回收器会自动回收它们占用的内存。
- **重用**：局部变量的名称可以在不同的方法或代码块中重复使用，因为它们的作用域是局部的，不会引起命名冲突。
- **参数和返回值**：**方法的参数**可以视为一种**特殊的局部变量**，它们在**方法被调用时初始化**，并在**方法返回后生命周期结束**。

在下面的例子中 age 变量没有初始化，所以在编译时会出错：

```java
package com.runoob.test;
 
public class Test{ 
   public void pupAge(){
      int age;
      age = age + 7;
      System.out.println("小狗的年龄是 : " + age);
   }
   
   public static void main(String[] args){
      Test test = new Test();
      test.pupAge();
   }
}
```

以上实例编译运行结果如下:

```java
Test.java:4:variable number might not have been initialized
age = age + 7;
         ^
1 error
```

# 四、成员变量（实例变量）

- 成员变量声明在一个类中，但在方法、构造方法和语句块之外。
- 当一个对象被实例化之后，每个成员变量的值就跟着确定。
- **成员变量在对象创建的时候创建，在对象被销毁的时候销毁。**
- 成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。
- 成员变量可以声明在使用前或者使用后。
- 访问修饰符可以修饰成员变量。
- 成员变量对于类中的方法、构造方法或者语句块是可见的。**一般情况下应该把成员变量设为私有**。通过**使用访问修饰符可以使成员变量对子类可见**。
- **成员变量具有默认值**。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。**变量的值可以在声明时指定，也可以在构造方法中指定**；
- 成员变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：`ObjectReference.VariableName`。

成员变量的声明语法为：

```java
accessModifier type variableName;
```

- `accessModifier` --表示访问修饰符，可以是 public、protected、private 或默认访问级别（即没有显式指定访问修饰符）。
- `type` -- 表示变量的类型。
- `variableName` -- 表示变量的名称。

与局部变量不同，成员变量的值在创建对象时被分配，**即使未对其初始化，它们也会被赋予默认值**，例如 int 类型的变量默认值为 0，boolean 类型的变量默认值为 false。

成员变量可以通过对象访问，也可以通过类名访问（如果它们是静态成员变量）。如果没有显式初始化成员变量，则它们将被赋予默认值。可以在构造函数或其他方法中初始化成员变量，或者通过对象或类名访问它们并设置它们的值。

# 五、类变量（静态变量）

Java 中的静态变量是指在类中定义的一个变量，它**与类相关而不是与实例相关**，即**无论创建多少个类实例，静态变量在内存中只有一份拷贝，被所有实例共享。**

静态变量在**类加载时被创建**，在**整个程序运行期间都存在**。

## 5.1 定义方式

静态变量的定义方式是在类中使用 static 关键字修饰变量，通常也称为类变量。

以下实例中我们定义一个静态变量 **count** ，其初始值为 0：

```java
public class MyClass {
    public static int count = 0;
    // 其他成员变量和方法
}
```

## 5.2 访问方式(两种方式)

由于静态变量是与类相关的，因此可以**通过类名来访问静态变量**，也可以**通过实例名来访问静态变量**。

```java
MyClass.count = 10; // 通过类名访问
MyClass obj = new MyClass();
obj.count = 20; // 通过实例名访问
```

## 5.3 初始化时机

静态变量在类加载时被初始化，其**初始化顺序与定义顺序有关**。

如果一个静态变量**依赖**于另一个静态变量，那么它**必须在后面定义**。

```java
public class MyClass {
    public static int count1 = 0;
    public static int count2 = count1 + 1;
    // 其他成员变量和方法
}
```

上面的例子中，count1 要先于 count2 初始化，否则编译时会报错。

## 5.4 常量和静态变量的区别

**常量**也是**与类相关**的，但它是**用 final  关键字修饰**的变量，**一旦被赋值就不能再修改**。与静态变量不同的是，**常量在编译时就已经确定了它的值**，而**静态变量的值可以在运行时改变**。另外，**常量通常用于存储一些固定的值，如数学常数、配置信息**等，而**静态变量通常用于存储可变的数据，如计数器、全局状态**等。

总之，静态变量是与类相关的变量，具有唯一性和共享性，可以用于存储整个程序都需要使用的数据，但需要注意初始化时机和与常量的区别。

## 5.5 静态变量的线程安全性

Java 中的静态变量是属于类的，而不是对象的实例。因此，当**多个线程同时访问一个包含静态变量的类时**，需要**考虑其线程安全性**。

**静态变量在内存中只有一份拷贝，被所有实例共享**。因此，如果一个线程修改了静态变量的值，那么其他线程在访问该静态变量时也会看到修改后的值。这可能会导致并发访问的问题，因为**多个线程可能同时修改静态变量，导致不确定的结果或数据一致性问题**。

为了确保静态变量的线程安全性，需要采取**适当的同步措施**，如**同步机制、原子类或 volatile 关键字**，以便在**多线程环境**中正确地读取和修改静态变量的值。

## 5.6 静态变量的使用场景

静态变量通常用于以下场景：

- 存储全局状态或配置信息
- 计数器或统计信息
- 缓存数据或共享资源
- 工具类的常量或方法
- 单例模式中的实例变量