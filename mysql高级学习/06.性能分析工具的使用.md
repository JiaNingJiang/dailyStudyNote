# 一、性能分析工具的使用

## 1.1 数据库服务器的优化步骤

当我们遇到**数据库调优问题**的时候，该如何思考呢？这里把思考的流程整理成下面这张图。

整个流程划分成了 **观察（Show status）** 和 **行动（Action）** 两个部分。字母 S 的部分代表观察（会使用相应的**分析工具**），字母 A 代表的部分是行动（**对应分析可以采取的行动**）。

![image-20231113181448930](06.性能分析工具的使用.assets/image-20231113181448930-16998704907202.png)

我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解**执行慢的 `SQL` 都有哪些**，查看**具体的 `SQL` 执行计划**，甚至是 **`SQL` 执行中的每一步的成本代价**，这样才能定位问题所在，找到了问题，再采取相应的行动。

**详细解释一下这张图:**

首先在 `S1` 部分，我们需要观察服务器的状态**是否存在周期性的波动**。如果存在周期性波动，可能是**周期性节点**的原因，比如**双十一、促销活动**等。这样的话，我们可以通过 `A1` 这一步骤解决，也就是**加缓存**，或者**更改缓存失效策略**。

如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因，接下来进入 `S2` 这一步，我们需要**开启慢查询**。

**慢查询可以帮我们定位执行慢的 `SQL` 语句**。我们可以通过**设置`long.query_time`参数定义“慢”的阈值**，如果 **`SQL` 执行时间超过了`long_query_time`，则会认为是慢查询**。当收集上来这些慢查询之后，我们就可以通过分析工具对**慢查询日志**进行分析。

在 `S3` 这一步骤中，我们就知道了执行慢的 `SQL`，这样就可以针对性地**用 `EXPLAIN` 查看对应 `SQL `语句的执行计划**，或者使用 **`show profile`查看 `SQL` 中每一个步骤的时间成本**。这样我们就可以了解 `SQL` 查询慢是因为**执行时间长**，还是**等待时间长**。

如果是 `SQL` 等待时间长，我们进入 `A2` 步骤。在这一步骤中，我们可以**调优服务器的参数**，比如适当**增加数据库缓冲池**等。如果是 **`SQL` 执行时间长**，就进入 `A3` 步骤，这一步中我们需要考虑是**索引设计的问题**？还是查询**关联的数据表过多**？还是因为**数据表的字段设计问题**导致了这一现象。然后在这些维度上进行对应的调整。

如果 `A2` 和 `A3` 都不能解决问题，我们需要考虑**数据库自身的 `SQL` 查询性能是否已经达到了瓶颈**，如果确认没有达到性能瓶颈，就需要重新检查，重复以上的步骤。如果已经**达到了性能瓶颈**，进入 `A4` 阶段，需要考虑**增加服务器**，采用**读写分离的架构**，或者考虑**对数据库进行分库分表**，比如垂直分库、垂直分表和水平分表等。

以上就是数据库调优的流程思路。如果我们发现执行 `SQL` 时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的 `SQL` ，这三种分析工具你可以理解是`SQL`调优的三个步骤：**慢查询**、**EXPLAIN**和 **SHOW PROFILING**。

<img src="https://img-blog.csdnimg.cn/7cec787cb8ec46fe96561bc4df5d880f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcHJlZmVjdF9zdGFydA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" />

## 1.2 查看系统性能参数

在 `MySQL` 中，可以使用 `SHOW STATUS` 语句查询一些 `MySQL` 数据库服务器的性能参数 、执行频率 。

`SHOW STATUS`语句语法如下：

一些常用的性能参数如下：

    Connections：连接MySQL服务器的次数。
    Uptime：MySQL服务器的上线时间。
    Slow_queries：慢查询的次数。
    Innodb_rows_read：Select查询返回的行数
    Innodb_rows_inserted：执行INSERT操作插入的行数
    Innodb_rows_updated：执行UPDATE操作更新的行数
    Innodb_rows_deleted：执行DELETE操作删除的行数
    Com_select：查询操作的次数。
    Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。
    Com_update：更新操作的次数。
    Com_delete：删除操作的次数。
## 1.3 统计 `SQL `的查询成本：`last_query_cost`

一条 `SQL` 查询语句在执行前需要**确定查询执行计划**，如果**存在多种执行计划**的话，`MySQL `会**计算每个执行计划所需要的成本**，从中**选择成本最小的一个**作为**最终执行的执行计划**。

如果我们想要**查看某 `SQL` 语句的查询成本**，可以在执行完这条 `SQL` 语句之后，通过**查看当前会话中的 `last_query_cost` 变量值**来得到**当前查询的成本**。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本**对应的是SQL语句所需要读取的页的数量**。

```sql
SHOW STATUS LIKE 'last_query_cost';
```

使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。

> `SQL` 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：
>
> - 位置决定效率。如果**页就在数据库缓冲池**中，那么**效率是最高的**，否则还需要**从内存或者磁盘中进行读取**，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
>
> - 批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多 `10ms` ），而采用**顺序读取的方式**，**批量对页进行读取**，**平均一页的读取效率就会提升很多**，甚至要快于单个页面在内存中的随机读取。
>
> 所以说，遇到 I/O 并不用担心，方法找对了，效率还是很高的。我们**首先要考虑数据存放的位置**，如果是**经常使用的数据就要尽量放到缓冲池**中，其次我们可以充分利用磁盘的吞吐能力，**一次性批量读取数据**，这样**单个页的读取效率也就得到了提升**。

# 二、定位执行慢的 `SQL`：慢查询日志

## 2.1 开启慢查询日志参数

`MySQL` 的**慢查询日志**，用来记录在 `MySQL` 中 **响应时间超过阈值** 的语句，具体指**运行时间超过 `long_query_time` 的值的 `SQL`** ，则会被记录到慢查询日志中。long_query_time的**默认值为`10`**，意思是**运行10秒以上（不含10秒）的语句**，认为是超出了我们的最大忍耐时间值。

它的主要作用是，帮助我们发现那些**执行时间特别长的 `SQL` 查询**，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条`SQL` 执行超过5秒钟，我们就算慢 `SQL` ，希望能**收集超过5秒的`SQL`**，**结合explain进行全面分析**。

默认情况下，`MySQL`数据库**没有开启慢查询日志**，需要我们**手动来设置这个参数**。**如果不是调优需要的话，一般不建议启动该参数**，因为开启慢查询日志会或多或少带来一定的性能影响。

慢查询日志**支持将日志记录写入文件**。

<img src="06.性能分析工具的使用.assets/image-20231113201444157.png" alt="image-20231113201444157" style="zoom:67%;" />

### 2.1.1 开启 slow_query_log

```SQL
set global slow_query_log='ON';
```

查看下慢查询日志**是否开启**，以及慢查询**日志文件的位置**：

```sql
show variables like `%slow_query_log%`;
```

### 2.1.2 修改 long_query_time 阈值

```sql
show variables like '%long_query_time%';
```

测试发现：**设置 `global` 的方式对当前 `session` 的long_query_time无效**。**对新连接的客户端有效**。所以可以**一并执行下述语句：**

```sql
mysql > set global long_query_time = 1;   ## 针对新连接的session
mysql> show global variables like '%long_query_time%'; 

mysql> set long_query_time=1;  ## 针对当前 session
mysql> show variables like '%long_query_time%';
```

### 2.1.3 查看慢查询数目

```sql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

### 2.1.4 慢查询日志分析工具：`mysqldumpslow`

在生产环境中，如果要手工分析日志，查找、分析 `SQL`，显然是个体力活，`MySQL` 提供了**日志分析工具 `mysqldumpslow`** 。

 查看 `mysqldumpslow` 的帮助信息

```sql
mysqldumpslow --help
```

![在这里插入图片描述](06.性能分析工具的使用.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcHJlZmVjdF9zdGFydA==,size_20,color_FFFFFF,t_70,g_se,x_16-16998780730436.png)

`mysqldumpslow` 命令的具体参数如下：

    -a: 不将数字抽象成N，字符串抽象成S
    -s: 是表示按照何种方式排序：
        c: 访问次数
        l: 锁定时间
        r: 返回记录
        t: 查询时间
        al:平均锁定时间
        ar:平均返回记录数
        at:平均查询时间 （默认方式）
        ac:平均查询次数
    -t: 即为返回前面多少条的数据；
    -g: 后边搭配一个正则匹配模式，大小写不敏感的；
举例：我们想要**按照查询时间排序**，查看**前五条** 慢查询 `SQL` 语句，这样写即可：

```sql
mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log

[root@bogon ~]# mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log 
Reading mysql slow query log from /var/lib/mysql/atguigu01-slow.log 
Count: 1 Time=2.39s (2s) Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost SELECT * FROM student WHERE name = 'S' 
Count: 1 Time=2.09s (2s) Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost SELECT * FROM student WHERE stuno = N 
Died at /usr/bin/mysqldumpslow line 162, <> chunk 2.
```

### 2.1.5 关闭慢查询日志

1. 方式1：永久性方式

```ini	
## 修改mysql配置文件
[mysqld] 
slow_query_log=OFF
#或
[mysqld] 
#slow_query_log =OFF
```

2. 方式2：临时性方式(重启 `mysql` 后失效)

```sql
SET GLOBAL slow_query_log=off;
```

### 2.1.6 删除慢查询日志

使用 `SHOW` 语句显示慢查询日志信息，具体 `SQL` 语句如下。

```sql
SHOW VARIABLES LIKE 'slow_query_log% ';
```

找到对应的慢查询日志文件所在的路径，**使用`rm -rf` 指令可以将其删除**。

删除后，如果我们想要重新生成一个慢查询日志文件，可以使用命令`mysqladmin flush-logs` ，具体命令如下，执行完毕会在**数据目录**下**重新生成慢查询日志文件**：

```sql
mysqladmin -uroot -p fush-logs slow
```

## 2.2 查看 `SQL` 执行成本：`SHOW PROFILE`

```sql
show variables like 'profiling';
#开启
set profiling = 'ON';
#查看
show profiles;   ## 查看近期的所有SQL语句
show profile cpu,block io for query 2; # 查询ID=2的SQL语句
```

show profile 的常用查询参数:

    ALL:显示所有的开销信息。
    BLOCK IO:显示块Io开销。
    CONTEXT SWITCHES: 上下文切换开销。
    CPU:显示CPU开销信息。
    IPC:显示发送和接收开销信息。
    MEMORY:显示内存开销信息。
    PAGE FAULTS:显示页面错误开销信息。
    SOURCE:显示和Source_function，Source_file，Source_line相关的开销信息。
    SWAPS:显示交换次数开销信息。
## 2.3 分析查询语句：EXPLAIN

定位了查询慢的 `SQL` 之后，我们就可以使用 **`EXPLAIN` 或 `DESCRIBE` 工具**做针对性的分析**查询语句DESCRIBE语句**的使用方法与**EXPLAIN语句**是一样的，并且分析结果也是一样的。

`MySQL` 中有专门负责优化 `SELECT` 语句的**优化器模块**，主要功能：通过计算分析系统中收集到的统计信息，**为客户端请求的`Query` 提供它认为最优的执行计划**（他认为最优的数据检索方式，但不见得是 `DBA` 认为是最优的，**这部分最耗费时间**)。

这个**执行计划展示了接下来具体执行查询的方式**，比如**多表连接的顺序**是什么，对于**每个表采用什么访问方法来具体执行查询**等等。`MysQL` 为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，大家看懂EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。

```
官方文档：
https://dev.mysql.com/doc/refman/5.7/en/explain-output.html
https://dev.mysql.com/doc/refman/8.0/en/explain-output.html
```

**版本情况**
`MySQL 5.6.3` 以前只能 `EXPLAIN SELECT` ；`MYSQL 5.6.3`以后就可以 `EXPLAIN SELECT，UPDATE，DELETE`。

在 `5.7` 以前的版本中，想要显示 `partitions` 需要使用 `explain partitions` 命令；想要显示 `filtered` 需要使用 `explain extended` 命令。在 `5.7` 版本后，默认`explain` 直接显示 `partitions` 和 `filtered` 中的信息。  

### 2.3.1 语法

```sql
EXPLAIN SELECT select_options 
#或者
DESCRIBE SELECT select_options
```

如果我们想看看**某个查询的执行计划**的话，可以在**具体的查询语句**前边加一个 EXPLAIN ，就像这样 ：

```sql
mysql> EXPLAIN SELECT 1;
```

![在这里插入图片描述](06.性能分析工具的使用.assets/b75ffe427e914e19a538b5d0c9f69ec6.png)

**输出的上述信息就是所谓的执行计划**。在这个执行计划的辅助下，我们需要知道应该怎样改进自己的查询语句以使查询执行起来更高效。其实**除了以SELECT开头的查询语句**，其余的**DELETE、INSERT、REPLACE以及UPDATE语句等都可以加上 EXPLAIN**，用来查看这些语句的执行计划，只是平时我们对SELECT语句更感兴趣。

> 执行EXPLAIN时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。

EXPLAIN 语句输出的各个列的作用如下：

| 列名          | 描述                                                    |
| ------------- | ------------------------------------------------------- |
| id            | 在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id |
| select_type   | SELECT关键字对应的那个查询的类型                        |
| table         | 表名                                                    |
| partitions    | 匹配的分区信息                                          |
| type          | 针对单表的访问方法                                      |
| possible_keys | 可能用到的索引                                          |
| key           | 实际上使用的索引                                        |
| key_len       | 实际使用到的索引长度                                    |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息  |
| rows          | 预估的需要读取的记录条数                                |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比            |
| Extra         | 一些额外的信息                                          |

### 2.3.2 基本语法

测试用的表结构:

```sql
CREATE TABLE s1 ( 
	id INT AUTO_INCREMENT, 
    key1 VARCHAR(100), 
    key2 INT, 
    key3 VARCHAR(100), 
    key_part1 VARCHAR(100), 
    key_part2 VARCHAR(100), 
    key_part3 VARCHAR(100), 
    common_field VARCHAR(100), 
    PRIMARY KEY (id), 
    INDEX idx_key1 (key1), 
    UNIQUE INDEX idx_key2 (key2), 
    INDEX idx_key3 (key3), 
    INDEX idx_key_part(key_part1, key_part2, key_part3) ) ENGINE=INNODB CHARSET=utf8;
```

#### 2.3.1.1 table

不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要**对每个表进行单表访问**的，所以 `MySQL` 规定**EXPLAIN语句输出的每条记录都对应着某个单表的访问方法**，该条记录的table列代表着**该表的表名**（有时会出现中间表）。

#### 2.3.1.2 id

**id 的数量与 `SELECT` 关键字的数量有关。** 

##### 2.3.1.2.1 针对一个表的一个`SELECT`

我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里**只有一个 SELECT 关键字**，比如下边这个查询语句：  

```sql
SELECT * FROM s1 WHERE key1 = 'a';
```

对上述语句进行`EXPLAIN`，可以看到**对 `s1` 表进行了一次查询**。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
```

![image-20231113221717188](06.性能分析工具的使用.assets/image-20231113221717188-16998850383779.png)

##### 2.3.1.2.2 针对两个表的一个`SELECT`

稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：  

```sql
SELECT * FROM s1 INNER JOIN s2
ON s1.key1 = s2.key1
WHERE s1.common_field = 'a';
```

进行解析，可以看到**分别针对两个表**（s1和s2）**各自进行了一次查询**（从上往下顺序的执行，因为**两次查询的 id 相同**）。

![image-20231113221742700](06.性能分析工具的使用.assets/image-20231113221742700-169988506397810.png)

##### 2.3.1.2.3 针对两个表的两个`SELECT`

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
```

![image-20231113222131054](06.性能分析工具的使用.assets/image-20231113222131054-169988529287811.png)

分别**针对两个表（s1和s2）各自进行了一次查询**（进行的是**倒序的查询**，先进行 id  = 2 的查询，再进行 id = 1 的查询）。

##### 2.3.1.2.4 `UNION` 去重

```sql
mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
```

![image-20231113222554908](06.性能分析工具的使用.assets/image-20231113222554908-169988555695012.png)

除了分别先后对 s2 和 s1 进行了一次查询，同时因为使用了临时表（因为是**联合 + 去重**，必须**先用一个临时表临时存储联合的结果**，再**针对临时表进行去重**）额外进行了一次查询。

##### 2.3.1.2.5 `UNION ALL`

```sql
mysql> EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
```

![image-20231113222847757](06.性能分析工具的使用.assets/image-20231113222847757-169988572921113.png)

因为不需要去重，因此不需要创建临时表，因此没有额外的第三次查询。

##### 2.3.1.2.6 总结

- **id如果相同，可以认为是一组**，从上往下顺序执行
- 在所有组中，**id值越大，优先级越高**，越先执行
- 关注点：**id号每个号码**，表示一趟**独立的查询**, 一个`SQL`的查询趟数越少越好  