# 一、数据库事务概述

## 1.1 存储引擎支持情况  

`SHOW ENGINES` 命令来查看当前 `MySQL` 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。  

![image-20231120201813573](10.事务基础知识.assets/image-20231120201813573-17004826949111.png)

在 `MySQL` 中，**只有 `InnoDB`** 是**支持事务**的。  

## 1.2  基本概念

**事务**：一组逻辑操作单元，**使数据从一种状态变换到另一种状态**。
**事务处理的原则**：保证**所有事务**都作为 **一个工作单元** 来执行，即使出现了故障，都不能改变这种执行方式。

当在**一个事务中执行多个操作**时，要么**所有的事务都被提交( commit )**，那么这些修改就 **永久** 地保存下来；要么数据库管理系统将 **放弃** 所作的 **所有修改** ，整个事务**回滚( rollback )到最初状态**。  

## 1.3  事务的ACID特性  

### 1.3.1  原子性（atomicity）  

原子性是指事务是一个不可分割的工作单位，**要么全部提交**，**要么全部失败回滚**。  

### 1.3.2  一致性（consistency）  

根据定义，一致性是指**事务执行前后**，数据从一个 **合法性状态** 变换到另外一个 **合法性状态** 。这种状态是 **语义上** 的而不是语法上的，**跟具体的业务有关**。

那什么是**合法的数据状态**呢？满足 **预定的约束** 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。**满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的**！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。  

![image-20231120202251647](10.事务基础知识.assets/image-20231120202251647-17004829733282.png)

### 1.3.3  隔离型（isolation）  

事务的隔离性是指一个事务的执行 **不能被其他事务干扰** ，即**一个事务内部的操作及使用的数据**对 **并发** 的**其他事务**是**隔离的**，并发执行的各个事务之间**不能互相干扰**。

如果**无法保证隔离性**会怎么样？假设A账户有200元，B账户0元。A账户往B账户**转账两次**，每次金额为50元，分别在**两个事务中执行**。如果无法保证隔离性，会出现下面的情形：  

![image-20231120202421005](10.事务基础知识.assets/image-20231120202421005-17004830618693.png)

### 1.3.4 持久性（durability）  

持久性是指**一个事务一旦被提交**，它对数据库中数据的改变就是 **永久性的** ，接下来的**其他操作和数据库故障**不应该对其有**任何影响**。

持久性是通过 **事务日志** 来保证的。日志包括了 **重做日志** 和 **回滚日志** 。

当我们通过事务对数据进行修改的时候，首先会**将数据库的变化信息记录到重做日志中**，然后**再对数据库中对应的行进行修改**。这样做的好处是，即使**数据库系统崩溃**，数据库**重启后**也能**找到**没有更新到数据库系统中的**重做日志**，**重新执行**，从而使事务具有持久性。  

## 1.4  事务的状态  

我们现在知道 **事务** 是一个抽象的概念，它其实对应着一个或多个数据库操作，`MySQL` 根据这些操作所执行的不同阶段把 **事务** 大致**划分成几个状态**：  

- **活动的（active）**

  事务对应的数据库**操作正在执行过程中**时，我们就说该事务处在 活动的 状态。

- **部分提交的（partially committed）**

  当事务中的**最后一个操作执行完成**，但由于操作都在内存中执行，所造成的影响并 **没有刷新到磁盘时**，我们就说该事务处在 部分提交的 状态。

- **失败的（failed）**

  当事务处在 **活动的** 或者 **部分提交的** 状态时，可能**遇到了某些错误**（数据库自身的错误、操作系统错误或者直接断电等）而**无法继续执行**，或者**人为的停止当前事务的执行**，我们就说该事务处在 失败的 状态。  

- **中止的（aborted）**

  如果事务执行了一部分而变为 **失败的** 状态，那么就需要**把已经修改的事务中的操作还原到事务执行前的状态**。换句话说，就是要**撤销失败事务对当前数据库造成的影响**。我们把这个撤销的过程称之为 **回滚** 。当 **回滚** 操作**执行完毕**时，也就是数据库**恢复到了执行事务之前的状态**，我们就说该事务处在了 中止的 状态  

- **提交的（committed）**   

  当一个处在 **部分提交的** 状态的事务将修改过的数据都 **同步到磁盘** 上之后，我们就可以说该事务处在了 提交的 状态  

一个基本的状态转换图如下所示：  

![image-20231120203045685](10.事务基础知识.assets/image-20231120203045685-17004834465624.png)

# 二、如何使用事务  

使用事务有两种方式，分别为 **显式事务** 和 **隐式事务** 。  

## 2.1  显式事务  

**步骤1**： `START TRANSACTION` 或者 `BEGIN` ，作用是**显式开启一个事务**。  

`START TRANSACTION` 语句相较于 `BEGIN` 特别之处在于，**后边能跟随几个修饰符** ：  

① **READ ONLY** ：标识当前事务是一个 **只读事务** ，也就是属于该事务的数据库操作**只能读取数据，而不能修改数据**。

② **READ WRITE** ：标识当前事务是一个 **读写事务** ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。

③ **WITH CONSISTENT SNAPSHOT** ：启动一致性读。  

**步骤2**：一系列事务中的操作（主要是 `DML` ，**不含 `DDL`**）  

**步骤3**：**提交事务** 或 **中止事务（即回滚事务）**  

```sql
# 提交事务。当提交事务后，对数据库的修改是永久性的。
mysql> COMMIT;

# 回滚事务。即撤销正在进行的所有没有提交的修改
mysql> ROLLBACK;
# 将事务回滚到某个保存点。
mysql> ROLLBACK TO [SAVEPOINT]
```

## 2.2  隐式事务  

`MySQL` 中有一个系统变量 `autocommit` ：  

```sql
mysql> SHOW VARIABLES LIKE 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit | ON |
+---------------+-------+
1 row in set (0.01 sec)
```

在 `ON` 的状态下，每执行一条 `DML` 语句，自动将其视为一个事务进行提交。 

当然，如果我们想**关闭这种自动提交的功能**，可以使用下边两种方法之一：  

1. 显式的的使用 `START TRANSACTION` 或者 `BEGIN` 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。
2. 把系统变量 `autocommit` 的值设置为 OFF ，就像这样：  

```sql
SET autocommit = OFF;
#或
SET autocommit = 0;
```

## 2.3  隐式提交数据的情况  

### 2.3.1  数据定义语言（`DDL`）

数据库对象，指的就是数据库、表、视图、存储过程等结构。当我们**使用CREATE、ALTER、DROP等语句去修改数据库对象**时，就会**隐式的提交前边语句所属于的事务**。

```sql
即:
BEGIN;
SELECT ... #事务中的一条语句
UPDATE ...#事务中的一条语句
...#事务中的其它语句

CREATE TABLE ...#此语句会隐式的提交前边语句所属于的事务
```

### 2.3.2 隐式使用或修改 `mysql` 数据库中的表 

当我们使用 `ALTER USER`、`CREATE USER`、`DROP USER`、`GRANT`、`RENAME USER`、`REVOKE`、`SET PASSWORD` 等语句时（**涉及到 `MySQL` 系统表的修改操作**）也会**隐式的提交前边语句所属于的事务**。

### 2.3.3  事务控制或关于锁定的语句

1. 情况一

当我们在**一个事务还没提交或者回滚**时就又使用`START TRANSACTION`或者`BEGIN`语句**开启了另一个事务**时，会**隐式的提交上一个事务**。

```sql
即:
BEGIN;
SELECT ...#事务中的一条语句
UPDATE ...#事务中的一条语句
...#事务中的其它语句
BEGIN;#此语句会隐式的提交前边语句所属于的事务
```

2. 情况二

当前的`autocommit`系统变量的值为`OFF`，我们**手动把它调为`ON`**时，也会**隐式的提交前边语句所属的事务**。

3. 情况三

使用`LOCK TABLES`、`UNLOCK TABLES`等关于锁定的语句也会**隐式的提交前边语句所属的事务**。

### 2.3.4  加载数据的语句

使用 `LOAD DATA` 语句来**批量往数据库中导入数据**时，也会**隐式的提交前达语句所属的事务**。

### 2.3.5  关于 `MySQL` 复制的一些语句

使用 `START SLAVE`、`STOP SLAVE` 、`RESET SLAVE` 、`CHANGE MASTER TO` 等语句时会**隐式的提交前边语句所属的事务**。

### 2.3.6  其它的一些语句

使用 `ANALYZE TABLE`、`CACHE INDEX`、`CHECK TABLE`、`FLUSH`、`LOAD INDEX INTO CACHE`、`OPTIMIZE TABLE`、`REPAIR TABLE`、`RESET` 等语句也会**隐式的提交前边语句所属的事务**。