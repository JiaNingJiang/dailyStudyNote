题目：

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

<img src="93.复原IP地址.assets/image-20230914223755753.png" alt="image-20230914223755753" style="zoom:50%;" />

题解：

```go
func restoreIpAddresses(s string) []string {
    res := []string{}
    curIP := make([]int, 4)  // 记录当前路径的IP
    
    var dfs func(int, int)
    // 每次生成IP地址四段中的一段
    dfs = func(IPSeg int, sStart int) {   // IPSeg表示当前正在合成第几段IP，sStart表示当前在s的哪一位上
        if IPSeg == 4 {   // 已经凑齐四段IP(0 1 2 3)
            if sStart == len(s) {   // 同时已经遍历完整个s字符串
                IPStr := ""
                for index,IP := range curIP {
                    IPStr += strconv.Itoa(IP)
                    if index != 3 {
                        IPStr += "."
                    }
                }
                res = append(res, IPStr)
                return
            } else {    // 已经合成了四段IP，但还没有遍历完整个s,那么当前合成路线是错误的
                return
            }
        }
        if sStart == len(s) {   // 已经遍历完s,但是还没有合成四段IP,则合成路线错误
            return
        }
        if s[sStart] == '0' {   // 当前位置是0，那么只能自己作为IP的一段(不需要回溯,因为只有这一种可能)
            curIP[IPSeg] = 0
            dfs(IPSeg+1, sStart+1)
            return
        }
        // 当前位置不为0，可以选择: 1.一位合成  2.两位合成  3.三位合成  
        // 原则是:合成的数值要小于等于255,且对s的访问不能越界
        addr := 0
        for sEnd := sStart; sEnd < len(s); sEnd++ {   // 对s不能访问越界
            addr = addr * 10 + int(s[sEnd] - '0')
            if addr <= 255 {   // 数值小于等于255, 可以作为合法的一段IP, 进行递归
                curIP[IPSeg] = addr
                dfs(IPSeg+1, sEnd+1)
            }
        }

    }
    dfs(0, 0)
    return res
}
```

