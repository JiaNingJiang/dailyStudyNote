题目：

给定一个**可包含重复数字**的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

<img src="47.全排列II.assets/image-20230912184218172.png" alt="image-20230912184218172" style="zoom:50%;" />

题解：

```go
func permuteUnique(nums []int) [][]int {
    res := [][]int{}
    curPath := []int{}

    hasRead := make(map[int]bool)   // 用来记录nums的某一个元素是否已经使用(key为下标)

    var dfs func()

    dfs = func() {
        if len(curPath) == len(nums) {
            res = append(res, append([]int(nil), curPath...))
            return
        }

        // 对于curPath的同一个位置，不能使用nums的不同位置但相同数值的元素(key是num[]的元素值)
        curLoc := make(map[int]bool)   // 仅在当前轮次内有效，下一个递归轮次中要重新初始化

        for i:=0; i<len(nums); i++ {
            if hasRead[i] == true {   // nums中已经使用过的数字不能再重复使用
                continue
            }
            if curLoc[nums[i]] {  // 虽然是没用过的数字,但是其值与已经用过的也相同,那么也不能重复作为curPath[i]
                continue
            } else {
                curLoc[nums[i]] = true
            }
            curNum := nums[i]
            hasRead[i] = true
            curPath = append(curPath, curNum)
            dfs()
            // 回溯
            hasRead[i] = false
            curPath = curPath[:len(curPath)-1]
        }
        
    }
    dfs()
    return res
}
```

