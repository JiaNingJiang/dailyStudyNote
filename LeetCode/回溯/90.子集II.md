题目：

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

<img src="90.子集II.assets/image-20230914195643653.png" alt="image-20230914195643653" style="zoom:50%;" />

题解：

**方法一：每次递归为当前子集从`nums[]`中选择一个数值**

- 因为`num[]`中有重复的数值，因为要注意：为当前位选择一个数值时，不能选择重复的（在本次递归中用一个哈希表记录已经选过的数值）
- 在递归过程中，**上一次已经选过的元素(注意不是数值)**，就不能再重复选择了（已经选过的元素在`num[]`中标记为已读(`nums[i] = math.MinInt`)，递归完后再回溯）
- 如果一个子集满足：元素个数以及数值相等，只是顺序不同，那么这是一个子集。比如：[1,2] 和 [2,1] 就是一个子集。为了避免这种重复情况，将`nums[]`数组进行从小到大排序，然后每次递归时为当前位选择的数值 `curNum`必须满足：`curNum >= last`，`last`是上一轮递归选择的数值。

```go
func subsetsWithDup(nums []int) [][]int {
    res := [][]int{}
    curPath := []int{}

    var dfs func(int, int)

    dfs = func(last int,length int) {
        if len(curPath) == length {
            res = append(res, append([]int(nil), curPath...))
            return
        }
        haveSelect := make(map[int]bool)   // 记录本次递归中已经在curPath当前位上已经出现过的nums[]数值
        // 每次递归为curPath选择一位
        for i:=0; i<len(nums); i++ {
            curNum := nums[i]
            if curNum < last {   // 必须是单调递增, 即 curNum >= last
                continue
            }
            if curNum == math.MinInt {   // 已经选过的数字不能重复选
                continue
            }
            if haveSelect[curNum] {
                continue
            } else {
                haveSelect[curNum] = true
                curPath = append(curPath, curNum)
                tmp := nums[i]
                nums[i] = math.MinInt
                dfs(curNum ,length)
                curPath = curPath[:len(curPath)-1]
                nums[i] = tmp
            }
        }
    }
    sort.Ints(nums)
    for i:=0; i<=len(nums); i++ {
        dfs(nums[0]-1 ,i)
    }
    return res
}
```

**方法二：**

考虑数组 [1, 2, 2] ，选择前两个数，或者第一、三个数，都会得到相同的子集。

也就是说，对于当前选择的数 x ，若前面有与其相同的数 y ，且没有选择 y ，此时包含 x 的子集，必然会出现在包含 y 的所有子集中。

我们可以通过判断这种情况，来避免生成重复的子集。代码实现时，可以**先将数组排序**；迭代时，**若发现没有选择上一个数，且当前数字与上一个数相同，则可以跳过当前生成的子集。**

- 将`nums[]`数组进行排序，那么相等的数字一定是相邻的
- 当且仅当上一个`num[i-1]`没有被选择，而当前`num[i] == num[i-1]`时，不能选择`num[i-1]`

```go
func subsetsWithDup(nums []int) (ans [][]int) {
    sort.Ints(nums)
    t := []int{}
    var dfs func(bool, int)
    dfs = func(choosePre bool, cur int) {
        if cur == len(nums) {
            ans = append(ans, append([]int(nil), t...))
            return
        }
        dfs(false, cur+1)
        if !choosePre && cur > 0 && nums[cur-1] == nums[cur] {
            return
        }
        t = append(t, nums[cur])
        dfs(true, cur+1)
        t = t[:len(t)-1]
    }
    dfs(false, 0)
    return
}
```

