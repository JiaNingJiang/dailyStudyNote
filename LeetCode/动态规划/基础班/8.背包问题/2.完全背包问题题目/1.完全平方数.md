题目：

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

<img src="1.完全平方数.assets/image-20231019153801199.png" alt="image-20231019153801199" style="zoom:50%;" />

题解：

### 方法一：完全背包问题解法

- 可选择的货物：就是 1^2，2^2, ……，sqrt(n)^2 这些不超过n的完全平方数
- 背包容量：就是n

需要注意的几点：

- 因为此题对于 `dp[i][j]`的设置，是选择数量最少作为最优值，因此初始的状态(也就是无法通过任何完全平方数组成的n)必须设置为`math.MaxInt`，否则会对 `dp[i][j] = getMin(dp[i-1][j], dp[i][j- i*i] + 1) `的设置造成干扰。如果非要把初始的状态设置为0，那么在完成对`dp[i][j]`的设置之前，必须分情况讨论，如下面的注释一样的操作。
- 对于` j - i*i == 0`这种情况，可以单独将其设置为`dp[i][j] = 1`，因为这必然是最优值。可以将其视为是 base case的一种情况。
- 注意：在完全背包问题中，` dp[i][j] = getMin(dp[i-1][j], dp[i][j- i*i] + 1)`，在选择物品i的情况中用`dp[i][j- i*i]` 代替了 `dp[i-1][j- i*i]`，原因是物品 `i` 可以无限使用

```go
func numSquares(n int) int {
    // 用背包问题解决，那么可选择的货物就是 1~sqrt(n), 背包的空间就是 n 
    scope := int(math.Sqrt(float64(n)))
    // dp[i][j]表示: 从 1~i 范围内选数，组成 n 时需要的完全平方数的最少数量
    dp := make([][]int, scope + 1)   // scope == 0 不使用
    for i := range dp {
        dp[i] = make([]int, n+1)  
    }
    // base case: j == 0, 只有0可以组成0（0*0 = 0），其他数都不可能组成0
    dp[0][0] = 1
    for i := 1; i <= scope; i++ {
        dp[i][0] = 0
    }
    for j:= 1; j <= n; j++ {
        dp[0][j] = 0
    }
    // base case: i == 1(因为1这个完全平方数可以无限制使用，因此从前往后遍历)
    // 这个 base case 的存在，可以代替dp[i][j]全部初始化为 math.MaxInt 的操作
    dp[1][1] = 1
    for j :=2; j <= n; j++ {
        dp[1][j] = dp[1][j- 1] + 1
    }

    for i := 2; i <= scope; i++ {   // 因为 i == 1已经被算出来了，所有从 i == 2开始
        for j := 1; j <= n; j++ {
            if j - i*i == 0 {   // 凑齐j，刚好就只需要 i*i 这一个完全平方数
                dp[i][j] = 1
            } else if j - i*i < 0 {  // 超额，只能选择不使用当前末尾的i
                dp[i][j] = dp[i-1][j]   
            } else {  // 可以选择使用或者不使用当前末尾的i, 但是选择需要完全平方数数量最少的那一个
                dp[i][j] = getMin(dp[i-1][j], dp[i][j- i*i] + 1)   // Im: 特别注意这里，因为是完全背包问题，每个物品都可以多次使用，因此在使用物品(数字i)的情况下，会有：dp[i][j- i*i] 这种额外的情况，也就是用了一次i之后，还可以再用一次（01背包每个物品只能用一次，因此在使用物品i的情况下，只有 dp[i-1][j- i*i] 这一种，也就是用了一次i之后，背包的剩余空间只能用 0~i-1 去继续装）
            }
        }
    }
    return dp[scope][n]
}

func getMin(a, b int) int {
    if a < b {
        return a
    } else {
        return b
    }
}
```



### 方法二：状态压缩（滚动数组）

```go
func numSquares(n int) int {
    // dp[j]：组成目标整数 j 需要使用的完全平方数的最少数量
    dp := make([]int, n+1)  
    dp[0] = 0  // 因为可用的完全平方数最小只能从1开始，因此对于目标整数为0，无法凑出
    // 因为 dp[j] 每次需要选择最小数量，因此初始化时都需要设置成 n + 1（全部用1去拼凑也仅需要n个），这样就不会造成干扰
    for j := 1; j <= n; j++ {
        dp[j] = n + 1  // 最好不用 math.MaxInt, 因为有时候可能会溢出
    }
    // 先物品还是先背包无所谓，这里用的是先物品后背包
    for i := 1; i*i <= n; i++ {     // 先遍历可用的完全平方数(可用的完全平方数有: 1, 4, 9,……,sqrt(n)^2)
        for j := i*i; j <= n; j++ {   // 完全背包问题，因为每个完全平方数可以重复使用，因此正序
            dp[j] = getMin(dp[j], dp[j - i*i] + 1)  // dp[j]是从上一行继承的，dp[j - i*i]则是本行新覆盖上的，等同于上一方法的dp[i][j- i*i]。dp[i-1][j- i*i]不会出现（总是被dp[i][j- i*i]覆盖）
        }
    }
    return dp[n]
}

func getMin(a, b int) int {
    if a < b {
        return a
    } else {
        return b
    }
}
```

