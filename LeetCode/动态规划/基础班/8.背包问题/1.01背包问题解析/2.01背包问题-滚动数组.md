滚动数组其实就是把背包问题的二维`dp`降为一维`dp`，即进行了状态压缩。

假设背包最大重量为4。

物品为：

|       | 重量 | 价值 |
| :---- | :--- | :--- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能背的物品最大价值是多少？

### 一维`dp`数组(滚动数组)

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`;

**其实可以发现如果把`dp[i - 1]`那一层拷贝到`dp[i]`上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])`;**

**于其把`dp[i - 1]`这一层拷贝到`dp[i]`上，不如只用一个一维数组了**，只用`dp[j]`（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件当前层的`dp[i]`仅依赖于上面一层的`dp[j]`，直接拷贝到当前层。

#### 1. 确定`dp`数组的定义

在一维`dp`数组中，`dp[j]`表示：容量为j的背包，所背的物品价值可以最大为`dp[j]`。

#### 2.一维`dp`数组的递推公式

`dp[j]`为 容量为`j`的背包所背的最大价值，那么如何推导`dp[j]`呢？

`dp[j]`可以通过`dp[j - weight[i]]`推导出来，`dp[j - weight[i]]`表示容量为`j - weight[i]`的背包所背的最大价值。

`dp[j - weight[i]] + value[i]` 表示 容量为` j - 物品i重量` 的背包 加上 `物品i的价值`。（也就是容量为j的背包，放入物品i了之后的价值即：`dp[j]`）

**此时`dp[j]`有两个选择：一个是取自己之前的(上一层的)`dp[j]`，一个是取`dp[j - weight[i]] + value[i]`（也是上一层的`dp[j - weight[i]]`）。**两者中取最大的，毕竟是求最大价值。

所以递归公式为：

```go
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

可以看出相对于二维`dp`数组的写法，就是把`dp[i][j]`中`i`的维度去掉了。

#### 3.一维`dp`数组如何初始化

`dp[j]`表示：容量为j的背包，所背的物品价值可以最大为`dp[j]`，那么**`dp[0]`就应该是0，因为背包容量为0所背的物品的最大价值就是0。**

那么`dp`数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

看一下递归公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`

**`dp`数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。**

**这样才能让`dp`数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

那么我假设物品价值都是大于0的，所以`dp`数组初始化的时候，都初始为0就可以了。

#### 4.一维`dp`数组遍历顺序

```go
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

**这里大家发现和二维`dp`的写法中，遍历背包(j)的顺序是不一样的！**

二维`dp`遍历的时候，背包容量是**从小到大**，而一维`dp`遍历的时候，背包是**从大到小**。

为什么呢？

**倒叙遍历是为了保证物品i只被放入一次！**

举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果**正序遍历**:

`dp[1] = dp[1 - weight[0]] + value[0] = 15`

`dp[2] = dp[2 - weight[0]] + value[0] = 30`

此时`dp[2]`就已经是30了，意味着**物品0，被放入了两次**，所以不能正序遍历。

为什么**倒叙遍历**，就可以保证物品只放入一次呢？

倒叙就是先算`dp[2]`

`dp[2] = dp[2 - weight[0]] + value[0] = 15`  （**`dp`数组已经都初始化为0**）

`dp[1] = dp[1 - weight[0]] + value[0] = 15`

所以**从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了**。

**那么问题又来了，为什么二维`dp`数组历的时候不用倒叙呢？**

因为对于二维`dp`，`dp[i][j]`都是通过上一层即`dp[i - 1][j]`计算而来，本层的`dp[i][j]`并不会被覆盖！因此**对于二维`dp`来说，对于背包到底是正序遍历还是倒序遍历都是可以的**。**但是对于初始一行，也就是仅有0号物品的一行必须是倒序遍历。**



**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

**不可以！**

因为**一维`dp`的写法，背包容量一定是要倒序遍历**（原因上面已经讲了），**如果遍历背包容量放在外层，那么每个`dp[j]`就只会放入一个物品，即：背包里只放入了一个物品**。

或者可以这样理解：**每一次在不同的 i 下计算 `dp[j]`，当前 i 下的`dp[j]`其实都依赖于之前的 i - 1下获得的 `dp[j] `和 `dp[j - weight[i]`] ，因此 i 必须放在外循环，而且必须是从小到大的。**

**所以一维`dp`数组的背包在遍历顺序上和二维其实是有很大差异的！**，这一点大家一定要注意。

#### 5.举例推导`dp`数组

一维`dp`，费用用物品0，物品1，物品2 来遍历背包，最终得到结果如下：

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv65uJ2vbfGG2z2z5I4x6SbkvGWMRfLXxtNqtKXH1wpsqj21bKevc5xzHrRJiaXXZo2C6ojcKMYW05Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

#### 6.完整代码

```go
func change(bagWeight int, weight []int, values []int) int {
    // 初始化 dp
    dp := make([]int, bagWeight + 1)
    // base case: 
	dp[0] = 0
    // 对于一维dp(滚动数组)，必须先遍历物品(因为没有了base case的设置，因此必须从第0个物品开始)
    for(i := 0; i < len(weight); i++) { 
        for(j := bagWeight; j >= weight[i] ; j--) { // 然后再遍历背包容量,且必须是倒序(保证物品不被重复使用)
           dp[j] = max(dp[j], dp[j - weight[i]] + value[i])  // 之前的dp[j]是指之前的i下计算获得的dp[j]
       }
    }  
}
```

