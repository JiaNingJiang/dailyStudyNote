题目：

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

<img src="34.在排序数组中查找元素的第一个和最后一个位置.assets/image-20230929104044484.png" alt="image-20230929104044484" style="zoom: 67%;" />

题解：

```go
func searchRange(nums []int, target int) []int {
    // 分别找target在nums[]中的左边界和右边界
    left, right := 0, len(nums) - 1
    mid := 0

    mostLeft := 0    // 等于 target 的最左边界
    mostRight := len(nums) - 1  // 等于 target 的最右边界 

    // 先找左边界
    for {
        if left > right {
            break
        }
        mid = left + (right - left) / 2
        if target == nums[mid] {   // 缩小到左半区域
            right = mid - 1
        } else if target < nums[mid] {   // target 在左半区域
            right = mid - 1
        } else if nums[mid] < target {  // target 在右半区域
            left = mid + 1
        }
    }
    // 本质是要根据最后一次 mid 来进行返回
    // right 的取值范围是: [-1, len(nums) - 1]    mid = right + 1, nums[mid]时最后一个等于target的数字
    // right == -1 时，mid == 0   分为两种情况: 1. nums[mid] == target  2.nums[mid] != target
    // right == len(nums) - 1 时, mid == len(nums) 
    if right == len(nums) - 1 || nums[right + 1] != target {  
        mostLeft = -1
    } else {
        mostLeft = right + 1   // right + 1 == mid
    }

    // 再找右边界
    left, right = 0, len(nums) - 1
    for {
        if left > right {
            break
        }
        mid = left + (right - left) / 2
        if target == nums[mid] {   // 缩小到右半区域
            left = mid + 1
        } else if nums[mid] < target {   // 到右半区域
            left = mid + 1
        } else if target < nums[mid] {   // 到左半区域
            right = mid - 1
        }
    }
    // left的取值范围是: [0, len(nums)]  mid = left - 1
    if left == 0 || nums[left - 1] != target {
        mostRight = -1
    } else {
        mostRight = left - 1
    }

    return []int{mostLeft, mostRight} 
}
```

